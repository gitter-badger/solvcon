============
Architecture
============

SOLVCON is built upon two keystones: (i) unstructured meshes for spatial
discretization and (ii) two-loop structure of partial differential equation
(PDE) solvers.  The data structure of unstructured meshes forms the foundation
layer, and the two basic loops forms the execution layer, as shown in Figure
:ref:`fig_stack`.  The two basic constructs supports the modules for physical
processes and numerical methods, on which applications are developed.

The layered architecture of SOLVCON allows users to write Python scripts to
drive the whole system.  This design helps automating simulations a lot.
Moreover, components in lower levels can be replaced in the driving scripts,
such that experimenting with new algorithms or implementation becomes very
easy.

.. _fig_stack:

.. figure:: _static/stack.png
  :width: 700px
  :alt: Architecture of SOLVCON
  :align: center

  Architecture of SOLVCON

Unstructured Meshes
===================

We usually discretize the spatial domain of interest before solving PDEs with
digital computers.  The discretized space is called a *mesh* [Mavriplis97]_.
When discretization is done by exploiting regularity in space, like cutting
along each of the Cartesian coordinate axes, the discretized space is called a
*structured mesh*.  If the discretization does not follow any spatial order, we
call the spatial domain an *unstructured mesh*.  Both meshing strategies have
their strength and weakness.  Sometimes a structured mesh is also call a
*grid*.  Numerical methods that rely on spatial discretization are called
*mesh-based* or *grid-based*.  Most PDE-solving methods in production uses are
mesh-based, but meshless methods have their advantages.

To accommodate complex geometry, SOLVCON chose to use unstructured meshes of
mixed elements.  Because no structure is assumed for the geometry to be
modeled, the mesh can be automatically generated by using computer programs.
For example, the following image shows a triangular mesh of a two-dimensional
irregular domain:

.. figure:: _static/ustmesh_2d_sample.png
  :width: 600px
  :align: center

  Two-dimensional sample mesh

which is generated by using the `Gmsh <http://geuz.org/gmsh/>`__ commands
listed in `ustmesh_2d_sample.geo`_.  On the other hand, creation of structured
meshes often needs a large amount of manual operations and will not be
discussed in this document.


In SOLVCON, we assume a mesh is fully covered by a finite number of
non-overlapping sub-regions, and only composed by these sub-regions.  The
sub-regions are called *mesh elements*.  In one-dimensional space, SOLVCON also
defines one type of mesh elements, *line*, as shown in Figure :ref:`f_elm_1d`.

.. _f_elm_1d:

.. figure:: _static/elm_1d.png
  :width: 150px
  :align: center

  One-dimensional mesh element

SOLVCON allows two types of two-dimensional mesh elements, *quadrilaterals* and
*triangles*, as shown in Figure :ref:`f_elm_2d`, and four types of
three-dimensional mesh elements, *hexahedra*, *tetrahedra*, *prisms*, and
*pyramids*, as shown in Figure :ref:`f_elm_3d`.

.. _f_elm_2d:

.. figure:: _static/elm_2d.png
  :width: 300px
  :align: center

  Two-dimensional mesh elements

.. _f_elm_3d:

.. figure:: _static/elm_3d.png
  :width: 600px
  :align: center

  Three-dimensional mesh elements

The numbers annotated in the figures are the order of the vertices of the
elements.  A SOLVCON mesh can be a mixture of elements of the same dimension,
although it is often composed of one type of element.  The meshes are defined
by various look-up tables in :py:class:`solvcon.block.Block`.

Entities
++++++++

Before explaining the data structure of the meshes, we need to introduce some
basic terminologies and definitions.  In SOLVCON, a *cell* means a mesh
element.  The dimensionality of a cell equals to that of the mesh it belongs
to, e.g., a two-dimensional mesh is composed by two-dimensional cells.  A cell
is assumed to be concave, and enclosed by a set of *faces*.  The dimensionality
of a face is one less than that of a cell.  A face is also assumed to be
concave, and formed by connecting a sequence of *nodes*.  The dimensionality of
a node is at least one less than that of a face.  Cells, faces, and nodes are
the basic constructs, which we call *entities*, of a SOLVCON mesh.

Defining the term "entity" for SOLVCON facilitates a unified treatment of two-
and three-dimensional meshes and the corresponding solvers [1]_.  A cell can be
either two- or three-dimensional, and the associated faces become one- or
two-dimensional, respectively.  Because a face is either one- or
two-dimensional, it can always be formed by a sequence of points, which is
zero-dimensional.  In this treatment, a point is equivalent to a node defined
in the previous passage.

Take the two-dimensional mesh shown above as an example, triangular elements
are used as the cells.  The triangles are formed by three lines
(one-dimensional shapes), which are the faces.  Each line has two points
(zero-dimensional).  If we have a three-dimensional mesh composed by hexahedral
cells, then the faces should be quadrilaterals (two-dimensional shapes).

All the mesh elements supported by SOLVCON are listed in the following table.
The first column is the name of the element, and the second column is the type
ID used in SOLVCON.  The third column lists the dimensionality.  The fourth,
fifth, and sixth columns show the number of zero-, one-, and two-dimensional
*sub*-entities belong to the element type, respectively.  Note that the terms
"point" and "line" appear in both the first row and first column, for they are
the only element type in the space of the corresponding dimensionality.

+---------------+------+-----+--------+-------+----------+
| Name          | Type | Dim | Point# | Line# | Surface# |
+===============+======+=====+========+=======+==========+
| Point         |    0 |   0 |      0 |     0 |        0 |
+---------------+------+-----+--------+-------+----------+
| Line          |    1 |   1 |      2 |     0 |        0 |
+---------------+------+-----+--------+-------+----------+
| Quadrilateral |    2 |   2 |      4 |     4 |        0 |
+---------------+------+-----+--------+-------+----------+
| Triangle      |    3 |   2 |      3 |     3 |        0 |
+---------------+------+-----+--------+-------+----------+
| Hexahedron    |    4 |   3 |      8 |    12 |        6 |
+---------------+------+-----+--------+-------+----------+
| Tetrahedron   |    5 |   3 |      4 |     4 |        4 |
+---------------+------+-----+--------+-------+----------+
| Prism         |    6 |   3 |      6 |     9 |        5 |
+---------------+------+-----+--------+-------+----------+
| Pyramid       |    7 |   3 |      5 |     8 |        5 |
+---------------+------+-----+--------+-------+----------+

Although SOLVCON doesn't support one-dimensional solvers, for completeness, we
define the relation between one-dimensional cells (lines) and their
sub-entities as:

+--------------+------+---------+
| Shape (type) | Face | = Point |
+==============+======+=========+
| Line (0)     |    0 | ∙ 0     |
+              +------+---------+
|              |    1 | ∙ 1     |
+--------------+------+---------+

That is, as shown in Figure :ref:`f_elm_1d`, a one-dimensional "cell" (line)
has two "faces", which are essentially point 0 and point 1.  Symbol ∙ indicates
a point.

It will be more practical to illustrate the relation between two-dimensional
cells and their sub-entities in a table (see Figure :ref:`f_elm_2d` for point
locations):

+-------------------+------+-------------------------+
| Shape (type)      | Face | = Line formed by points |
+===================+======+=========================+
| Quadrilateral (2) |    0 | ∕ 0 1                   |
+                   +------+-------------------------+
|                   |    1 | ∕ 1 2                   |
+                   +------+-------------------------+
|                   |    2 | ∕ 2 3                   |
+                   +------+-------------------------+
|                   |    3 | ∕ 3 0                   |
+-------------------+------+-------------------------+
| Triangle (3)      |    0 | ∕ 0 1                   |
+                   +------+-------------------------+
|                   |    1 | ∕ 1 2                   |
+                   +------+-------------------------+
|                   |    2 | ∕ 2 0                   |
+-------------------+------+-------------------------+

Symbol ∕ indicates a line.  The orientation of lines of each two-dimensional
shape is defined to follow the right-hand rule.  The shape enclosed by the
lines has an area normal vector points to the direction of :math:`+z` (outward
paper/screen).

The relation between three-dimensional cells and their sub-entities is defined
in the table (see Figure :ref:`f_elm_3d` for point locations):

+-----------------+------+----------------------------+
| Shape (type)    | Face | = Surface formed by points |
+=================+======+============================+
| Hexahedron (4)  |    0 | ☐ 0 3 2 1                  |
+                 +------+----------------------------+
|                 |    1 | ☐ 1 2 6 5                  |
+                 +------+----------------------------+
|                 |    2 | ☐ 4 5 6 7                  |
+                 +------+----------------------------+
|                 |    3 | ☐ 0 4 7 3                  |
+                 +------+----------------------------+
|                 |    4 | ☐ 0 1 5 4                  |
+                 +------+----------------------------+
|                 |    5 | ☐ 2 3 7 6                  |
+-----------------+------+----------------------------+
| Tetrahedron (5) |    0 | △ 0 2 1                    |
+                 +------+----------------------------+
|                 |    1 | △ 0 1 3                    |
+                 +------+----------------------------+
|                 |    2 | △ 0 3 2                    |
+                 +------+----------------------------+
|                 |    3 | △ 1 2 3                    |
+-----------------+------+----------------------------+
| Prism (6)       |    0 | △ 0 1 2                    |
+                 +------+----------------------------+
|                 |    1 | △ 3 5 4                    |
+                 +------+----------------------------+
|                 |    2 | ☐ 0 3 4 1                  |
+                 +------+----------------------------+
|                 |    3 | ☐ 0 2 5 3                  |
+                 +------+----------------------------+
|                 |    4 | ☐ 1 4 5 2                  |
+-----------------+------+----------------------------+
| Pyramid (7)     |    0 | △ 0 4 3                    |
+                 +------+----------------------------+
|                 |    1 | △ 1 4 0                    |
+                 +------+----------------------------+
|                 |    2 | △ 2 4 1                    |
+                 +------+----------------------------+
|                 |    3 | △ 3 4 2                    |
+                 +------+----------------------------+
|                 |    4 | ☐ 0 3 2 1                  |
+-----------------+------+----------------------------+

Symbol ☐ indicates a quadrilateral, while symbol △ indicates a triangle.

Because a face is associated to two adjacent cells unless it's a boundary face,
it needs to identify to which cell it belongs, and to which cell it is
neighbor.  The area normal vector of a face is always point from the belonging
cell to neighboring cell.  The same rule applies to faces of two-dimensional
meshes (lines) too.

Data Structure
++++++++++++++

.. py:module:: solvcon.block

Real data of unstructured meshes are stored in module
:py:class:`solvcon.block`.  A simple table for all element types is defined as
:py:obj:`elemtype`:

.. py:data:: elemtype

  A :py:class:`numpy.ndarray` object of shape (8, 5) and type ``int32``.  This
  array is a reference table for element types in SOLVCON.  The content is
  shown in the first table in Section `Entities`_.  Each row represents an
  element type.  The first column is the index of the element type, the second
  the dimensionality, the third column the number of points, the fourth the
  number lines, and the fifth the number of surfaces.

Class :py:class:`Block` contains descriptive information, look-up tables, and
other miscellaneous information for a SOLVCON mesh.  There are three steps
required to fully construct a :py:class:`Block` object: (i) instantiation, (ii)
definition, and (iii) build-up.  In the first step, when instantiating an
object, shape information must be provided to the constructor to allocate
arrays for look-up tables:

.. code-block:: python

  from solvcon.block import Block
  blk = Block(ndim=2, nnode=4, ncell=3)

Second, we fill the definition of the look-up tables into the object.  We at
least need to provide the node coordinates and the node lists of cells:

.. code-block:: python

  blk.ndcrd[:,:] = (0,0), (-1,-1), (1,-1), (0,1)
  blk.cltpn[:] = 3
  blk.clnds[:,:4] = (3, 0,1,2), (3, 0,2,3), (3, 0,3,1)

Third and finally, we build up the rest of the object by calling:

.. code-block:: python

  blk.build_interior()
  blk.build_boundary()
  blk.build_ghost()

By running the additional code, the block can be saved as a VTK file for viewing:

.. code-block:: python

  from solvcon.io.vtkxml import VtkXmlUstGridWriter
  iodev = VtkXmlUstGridWriter(blk)
  iodev.write('block_2d_sample.vtu')

.. _block_2d_sample:

.. figure:: _static/block_2d_sample.png
  :width: 150px
  :align: center

  A simple :py:class:`Block` object

.. py:class:: Block(ndim=0, nnode=0, nface=0, ncell=0, nbound=0, use_incenter=False)

  This class represents the unstructured meshes used in SOLVCON.  As such, in
  SOLVCON, an unstructured mesh is also called a *block*.  The following six
  attributes can be passed into the constructor.  :py:attr:`ndim`,
  :py:attr:`nnode`, and :py:attr:`ncell` need to be non-zero to instantiate a
  valid block.  :py:attr:`nface` and :py:attr:`nbound` might be different to
  the given value after building up the object.  :py:attr:`use_incenter` is an
  optional flag.

  .. py:attribute:: ndim

    :type: :py:class:`int`

    Number of dimensionalities of this mesh.  Read only after instantiation.

  .. py:attribute:: nnode

    :type: :py:class:`int`

    Total number of (non-ghost) nodes of this mesh.  Read only after
    instantiation.

  .. py:attribute:: nface

    :type: :py:class:`int`

    Total number of (non-ghost) faces of this mesh.  Read only after
    instantiation.

  .. py:attribute:: ncell

    :type: :py:class:`int`

    Total number of (non-ghost) cells of this mesh.  Read only after
    instantiation.

  .. py:attribute:: nbound

    :type: :py:class:`int`

    Total number of boundary faces or ghost cells of this mesh.  Read only
    after instantiation.

  .. py:attribute:: use_incenter

    :type: :py:class:`bool`

    Indicates calculating incenters instead of centroids for cells.  Default is
    ``False`` (using centroids of cells).
  
  To construct a block object, SOLVCON needs to know the dimensionalities
  (:py:attr:`ndim`), the number of nodes (:py:attr:`nnode`), faces
  (:py:attr:`nface`), and cells (:py:attr:`ncell`), and the number of boundary
  faces (:py:attr:`nbound`) of the mesh.  These keyword parameters are taken to
  initialize the following properties:

  The meshes are mainly defined by three sets of look-up tables (arrays).  The
  first set is the geometry arrays, which store the coordinate values of mesh
  elements:

  .. py:attribute:: ndcrd
    
    Coordinates of nodes.  It's a two-dimensional :py:class:`numpy.ndarray`
    array of shape (:py:attr:`nnode`, :py:attr:`ndim`) of type ``float64``.

  .. py:attribute:: fccnd
  
    Centroids of faces.  It's a two-dimension :py:class:`numpy.ndarray` of
    shape (:py:attr:`nface`, :py:attr:`ndim`) of type ``float64``.

  .. py:attribute:: fcnml
  
    Unit normal vectors of faces.  It's a two-dimension
    :py:class:`numpy.ndarray` of shape (:py:attr:`nface`, :py:attr:`ndim`) of
    type ``float64``.

  .. py:attribute:: fcara
  
    Areas of faces.  The value should always be non-negative.  It's a
    one-dimension :py:class:`numpy.ndarray` of shape (:py:attr:`nface`,) of
    type ``float64``.

  .. py:attribute:: clcnd
  
    Centroids of cells.  It's a two-dimension :py:class:`numpy.ndarray` of
    shape (:py:attr:`ncell`, :py:attr:`ndim`) of type ``float64``.

  .. py:attribute:: clvol
  
    Volumes of cells.  It's a one-dimension :py:class:`numpy.ndarray` of shape
    (:py:attr:`ncell`,) of type ``float64``.

  The second set is the meta-data or type data arrays:

  .. py:attribute:: fctpn

    Type ID of faces.  It's a one-dimensional :py:class:`numpy.ndarray` of
    shape (:py:attr:`nface`,) of type ``int32``.

  .. py:attribute:: cltpn

    Type ID of cells.  It's a one-dimensional :py:class:`numpy.ndarray` of
    shape (:py:attr:`ncell`,) of type ``int32``.

  .. py:attribute:: clgrp

    Group ID of cells.  It's a one-dimensional :py:class:`numpy.ndarray` of
    shape (:py:attr:`ncell`,) of type ``int32``.  For a new :py:class:`Block`
    object, it should be initialized with ``-1``.

  The third and last set is the connectivity arrays:

  .. py:attribute:: fcnds

    Lists of the nodes of each face.  It's a two-dimensional
    :py:class:`numpy.ndarray` of shape (:py:attr:`nface`, :py:attr:`FCMND`\ +1)
    and type ``int32``.

  .. py:attribute:: fccls

    Lists of the cells connected by each face.  It's a two-dimensional
    :py:class:`numpy.ndarray` of shape (:py:attr:`nface`, 4) and type
    ``int32``.

  .. py:attribute:: clnds

    Lists of the nodes of each cell.  It's a two-dimensional
    :py:class:`numpy.ndarray` of shape (:py:attr:`ncell`, :py:attr:`CLMND`\ +1)
    and type ``int32``.

  .. py:attribute:: clfcs

    Lists of the faces of each cell.  It's a two-dimensional
    :py:class:`numpy.ndarray` of shape (:py:attr:`ncell`, :py:attr:`CLMFC`\ +1)
    and type ``int32``.

  Every look-up array has two associated arrays distinguished by different
  prefixes: (i) ``gst`` (denoting for "ghost") and (ii) ``sh`` (denoting for
  "shared").  SOLVCON uses the technique of ghost cells to treat boundary
  conditions [Mavriplis97]_, and the ``gst`` arrays store the information for
  ghost cells.  However, to facilitate efficient indexing in solvers, each of
  the ghost arrays should be put in a continuous block of memory adjacent to
  its interior counterpart.  In SOLVCON, the ``sh`` arrays are the continuous
  memory blocks for both ghost and interior look-up tables, and a pair of
  ``gst`` and normal arrays is simply the views of two consecutive,
  non-overlapping sub-regions of a memory block.  More details of the technique
  of ghost cells will be given in module :py:mod:`solvcon.mesh`.

  There are some attributes associated with ghost cells:

  .. py:attribute:: ngstnode

    :type: :py:class:`int`

    Number of nodes only associated with ghost cells.  Only valid after
    build-up.  Read only.

  .. py:attribute:: ngstface

    :type: :py:class:`int`

    Number of faces only associated with ghost cells.  Only valid after
    build-up.  Read only.

  .. py:attribute:: ngstcell

    :type: :py:class:`int`

    Number of ghost cells.  Only valid after build-up.  Read only.

  Three arrays need to be defined before we can build up a :py:class:`Block`
  object: (i) :py:attr:`ndcrd`, (ii) :py:attr:`cltpn`, and (iii)
  :py:attr:`clnds`.  With these information, :py:meth:`build_interior` builds
  up the interior arrays for a :py:class:`Block` object.
  :py:meth:`build_boundary` then organizes the information for boundary
  conditions.  Finally, :py:meth:`build_ghost` builds up the shared and ghost
  arrays for the :py:class:`Block` object.  Only after the build-up process,
  the :py:class:`Block` object can be used by solvers.

  .. py:method:: build_interior

    :return: nothing

    Building up a :py:class:`Block` object includes two steps.  First, the
    method extracts arrays :py:attr:`clfcs`, :py:attr:`fctpn`,
    :py:attr:`fcnds`, and :py:attr:`fccls` from the defined arrays
    :py:attr:`cltpn` and :py:attr:`clnds`.  If the number of extracted faces is
    not the same as that passed into the constructor, arrays related to faces
    are recreated.

    Second, the method calculates the geometry information and fills the
    corresponding arrays.

  .. py:method:: build_boundary

    :return: nothing

    This method iterates over each of the :py:class:`solvcon.boundcond.BC`
    objects listed in :py:attr:`bclist` to collect boundary-condition
    information.  Unspecified boundary faces (i.e., faces that are not interior
    faces) will be collected to form an additional
    :py:class:`solvcon.boundcond.BC` object.  It sets :py:attr:`bndfcs` for
    later use by :py:meth:`build_ghost`.

  .. py:method:: build_ghost

    :return: nothing

    This method creates the shared arrays, calculates the information for ghost
    cells, and reassigns interior arrays as the right portions of the shared
    arrays.

  Attributes related to boundary-condition treatments:

  .. py:attribute:: bclist

    :type: :py:class:`list`

    The list of associated :py:class:`solvcon.boundcond.BC` objects.

  .. py:attribute:: nbound

    :type: :py:class:`int`

    Number of boundary faces.  Only valid after build-up.  It should equals to
    :py:attr:`ngstcell`.

  .. py:attribute:: bndfcs

    :type: :py:class:`numpy.ndarray`

    The array is of shape (:py:attr:`nbound`, 2) and type ``int32``.  Each row
    contains the data for a boundary face.  The first column is the 0-based
    index of the face, while the second column is the serial number of the
    associated :py:class:`solvcon.boundcond.BC` object.

.. py:currentmodule:: solvcon.block

In class :py:class:`Block` there are also useful constants defined:

  .. py:attribute:: Block.FCMND

    :type: :py:attr:`int`

    The maximum number of nodes that a face can have.  From the first table in
    Section `Entities`_, its value should be 4.

  .. py:attribute:: Block.CLMND

    :type: :py:attr:`int`

    The maximum number of nodes that a cell can have.  From the first table in
    Section `Entities`_, its value should be 8.

  .. py:attribute:: Block.CLMFC

    :type: :py:attr:`int`

    The maximum number of faces that a cell can have.  From the first table in
    Section `Entities`_, its value should be 6.

Basic Constructs
================

.. py:module:: solvcon.mesh

.. py:class:: Mesh

  This class represents the data set of unstructured meshes of mixed elements.

.. py:module:: solvcon.mesh_solver

.. py:class:: MeshSolver(blk, **kw)

  This is the base class for all solver classes that use
  :py:class:`solvcon.mesh.Mesh`.

.. py:class:: MeshCase(**kw)

  This is the base class for all simulation cases that use
  :py:class:`MeshSolver` (and in turn :py:class:`solvcon.mesh.Mesh`).

  init() and run() are the two primary methods responsible for the
  execution of the simulation case object.  Both methods accept a keyword
  parameter ``level`` which indicates the run level of the run:

  - run level 0: fresh run (default),
  - run level 1: restart run,
  - run level 2: initialization only.

A Dummy Solver
==============

To achieve high-performance in SOLVCON, the implementation of a numerical
method is divided into two parts: (i) a solver class and (ii) an algorithm
class.  A solver class is responsible for providing the API and managing
memory, while an algorithm class is responsible for number-crunching in C.
Users usually only see the solver class.  Intensive calculation is delegated to
the algorithm class from the solver class.  Two modules,
:py:mod:`solvcon.fake_solver` and :py:mod:`solvcon.fake_algorithm`, are put in
SOLVCON to exemplify the delegation structure by using a dummy numerical
method.

.. py:module:: solvcon.fake_solver

The :py:mod:`solvcon.fake_solver` module contains the
:py:class:`FakeSolver` class that defines the API for the
dummy numerical method.

.. py:class:: FakeSolver

  This class represents the Python side of the numerical method.  It
  instantiates a :py:class:`solvcon.fake_algorithm.FakeAlgorithm` object.
  Computation-intensive tasks are delegated to the algorithm object.

  .. py:method:: create_alg

    Create a :py:class:`solvcon.fake_algorithm.FakeAlgorithm` object and return it.

  .. py:attribute:: MMNAMES

    An ordered registry for all names of methods to be called by a marcher.  Any
    methods to be called by a marcher should be registered into it.

  The following six methods are for the numerical methods.  They are registered
  into :py:attr:`MMNAMES` by the present order.

  .. py:method:: update

    Update the present solution arrays with the next solution arrays.

  .. py:method:: calcsoln

    Calculate the ``soln`` array.

  .. py:method:: ibcsoln

    Interchange BC for the ``soln`` array.

  .. py:method:: calccfl

    Calculate the CFL number.

  .. py:method:: calcdsoln

    Calculate the ``dsoln`` array.

  .. py:method:: ibcdsoln

    Interchange BC for the ``dsoln`` array.

.. py:module:: solvcon.fake_algorithm

The :py:mod:`solvcon.fake_algorithm` module contains the
:py:class:`FakeAlgorithm` that interfaces to the number-crunching C code.

.. py:class:: FakeAlgorithm

  This class represents the C side of the numerical method.  It wraps two C
  functions :c:func:`sc_fake_algorithm_calc_soln` and
  :c:func:`sc_fake_algorithm_calc_dsoln`.

  .. py:method:: setup_algorithm(svr)

    A :py:class:`FakeAlgorithm` object shouldn't allocate memory.  Instead, a
    :py:class:`solvcon.fake_solver.FakeSolver` object should allocate the memory
    and pass the solver into the algorithm.

  .. py:method:: calc_soln

    Wraps the C functions :c:func:`sc_fake_algorithm_calc_soln`.  Do the work
    delegated from :py:meth:`solvcon.fake_solver.FakeSolver.calcsoln`.

  .. py:method:: calc_dsoln

    Wraps the C functions :c:func:`sc_fake_algorithm_calc_dsoln`.  Do the work
    delegated from :py:meth:`solvcon.fake_solver.FakeSolver.calcdsoln`.

Code Listings
=============

ustmesh_2d_sample.geo
+++++++++++++++++++++

.. literalinclude:: ../../contrib/gmsh/ustmesh_2d_sample.geo
  :language: c

The following command generate the mesh:

.. code-block:: bash

  gmsh ustmesh_2d_sample.geo -3

The following command converts the mesh to a VTK file for ParaView:

.. code-block:: bash

  scg mesh ustmesh_2d_sample.msh ustmesh_2d_sample.vtk

References
==========

.. [Mavriplis97] D. J. Mavriplis, Unstructured grid techniques, Annual Review
  of Fluid Mechanics 29. (1997)

.. rubric:: Footnotes

.. [1] SOLVCON focuses on two- and three-dimensional meshes.  But if we put an
  additional constraint on the mesh elements: Requiring them to be simplices,
  it wouldn't be difficult to extend the data structure of SOLVCON meshes into
  higher-dimensional space.

.. vim: set spell ff=unix fenc=utf8 ft=rst:
