#!/usr/bin/python
#
# sodtube1d.py
#
#
# 1D Sod Tube Test
#
# This program is implemented by OO style to be
# a part of ipython notebook demo materials.
#
# DEBUG: search string 'DEBUG'

import scipy.optimize as so

class PlotManager():
    """
    Manage how to show the data generated by SodTube.
    Roughly speaking, it is a wrapper of matplotlib
    """
    def __init__(self):
        pass

    def plotMesh(self, mesh):
        pass

    def plotSolution(self, solution):
        pass

class DataManager(PlotManager):
    """
    Manage how to get extended information by input data.
    """
    def __init__(self):
        pass

    def getErrorNorm(self, solution_A, solution_B):
        return solution_errornorm

    def getL2Norm(self, solution_A, solution_B):
        return solution_errornorm

class SodTube():
    """
    The core to generate the 1D Sod tube test
    """
    def __init__(self):
        # initial condition
        # [(rhol, ul, pl), (rhor, ur, pr)]
        #
        # Sod's initial condition
        self.RHOL = 1.0
        self.UL = 0.0
        self.PL = 1.0
        self.RHOR = 0.125
        self.UR = 0.0
        self.PR = 0.1
        self.initcondition_sod = [(self.RHOL, self.UL, self.PL),
                                  (self.RHOR, self.UR, self.PR)]
        # initial condition for a shock tube problem
        # default is Sod's initial condition
        # users could change this initial conditions
        self.initcondition = self.initcondition_sod
        # constants and conventions
        self.GAMMA = 1.4 # ideal gas constant
        self.GAMMA2 = (self.GAMMA - 1.0) / (self.GAMMA + 1.0)
        self.ALPHA = (self.GAMMA + 1.0) / (self.GAMMA - 1.0)
        self.BETA = (self.GAMMA - 1.0) / (2.0*self.GAMMA)
        # a mesh, which has this format:
        # [point0, point1, point2, point3, ......, pointn]
        self.mesh = []
        # solution has this format:
        # [(x0, rho0, u0, p0),
        #  (x1, rho1, u1, p1),
        #  ......,
        #  (xn, rhon, un, pn)]
        self.solution = []
        self.ceseparameters = []

    def getInitcondition(self):
        return self.initcondition

    def setInitcondition(self, initcondition):
        self.initcondition = initcondition

    def getMesh(self):
        return self.mesh

    def getAnalyticSolution(self):
        return self.calAnalyticSolution()

    def calAnalyticSolution(self, initcondition=None):
        # where implementing the code to get the analytic solution
        # by users' input condition
        # default is the Sod's condition
        initcondition = initcondition or self.initcondition
        solution = []
        return solution

    ##########################
    ### Analytical formula ###
    ##########################
    def analyticPressureRegionIV(self, x):
        # DEBUG: REMOVE ME AFTER DEVELOPMENT
        #return ((x-pr)*(((1.0-gamma2)/(rhor*(x+gamma2*pr)))**0.5)) - (((pl**beta)-(x**beta))*(((1.0-gamma2**2)*(pl**(1.0/gamma))/((gamma2**2)*rhol))**0.5)) # wiki

        # (10.51) Wesseling P.
        pI = self.PL
        pV = self.getPressureRegionV()
        cI = self.getVelocityCI()
        cV = self.getVelocityCV()
        beta = self.BETA
        gamma = self.GAMMA
        return ((x/pI) - ((1.0 - ((gamma-1.0)*cV*((x/pV) - 1.0))/(cI*((2.0*gamma*(gamma-1.0+(gamma+1.0)*(x/pV)))**0.5)))**(1.0/beta)))

    ################
    ### Velocity ###
    ################
    def getVelocityFanLeft(self):
        cI = self.getVelocityCI()
        return -cI

    def getVelocityFanRight(self):
        uIII = self.getAnalyticVelocityRegionIII()
        cIII = self.getVelocityCIII()
        return uIII - cIII

    def getVelocityShock(self):
        # P409, Wesseling P.
        cV = self.getVelocityCV()
        gamma = self.GAMMA
        pIV = self.getAnalyticPressureRegionIV()
        pV = self.getPressureRegionV()
        return cV*(1.0+(gamma+1.0)/2.0/gamma*((pIV/pV)-1.0))*0.5

    def getVelocityCI(self):
        return ((self.GAMMA*self.PL/self.RHOL)**0.5)

    def getVelocityCIII(self):
        pIII = self.getAnalyticPressureRegionIII()
        rhoIII = self.getAnalyticDensityRegionIII()
        return (self.GAMMA*pIII/rhoIII)**0.5

    def getVelocityCV(self):
        return ((self.GAMMA*self.PR/self.RHOR)**0.5)

    def getVelocityRegionI(self):
        return self.UL

    def getAnalyticVelocityRegionII(self, x, t):
        cI = self.getVelocityCI()
        gamma = self.GAMMA
        return 2.0/(gamma+1.0)*(cI+x/t)

    def getAnalyticVelocityRegionIII(self):
        return self.getAnalyticVelocityRegionIV()

    def getAnalyticVelocityRegionIV(self): # ~0.916 for Sod tube problem
        #gamma = self.GAMMA
        #cV = self.getVelocityCV()
        #pV = self.PR
        #return x - (ushock/gamma)*(x/pr-1.0)*(((2*gamma/(gamma+1.0))/((x/pr)+(gamma-1.0)/(gamma+1.0)))**0.5)

        # next to (10.51), P410, Wesseling P.
        # Need to verified...
        #cI = self.getVelocityCI()
        #beta = self.BETA
        #gamma = self.GAMMA
        #pI = self.getPressureRegionI()
        #pIV = self.getAnalyticPressureRegionIV()
        #return pI - x + 2.0/(gamma-1.0)*cI*(1.0 - (pIV/pI)**(beta))

        # next to (10.48), Wesseling P. # ~0.306 for Sod tube problem
        gamma = self.GAMMA
        pIV = self.getAnalyticPressureRegionIV()
        pV = self.getPressureRegionV()
        p = pIV/pV
        cV = self.getVelocityCV()
        return cV*(p-1.0)*(2.0/(gamma*(gamma-1.0+(gamma+1.0)*p)))**0.5

    def getVelocityRegionV(self):
        return self.UR

    ################
    ### Pressure ###
    ################
    def getPressureRegionI(self):
        return self.PL

    def getAnalyticPressureRegionII(self, x, t):
        # (10.44) Wesssling P.
        cI = self.getVelocityCI()
        uII = self.getAnalyticVelocityRegionII(x, t)
        pI = self.PL
        gamma = self.GAMMA
        beta = self.BETA
        return pI*(1.0-(gamma-1.0)*uII/2/cI)**(1.0/beta)

    def getAnalyticPressureRegionIII(self):
        return self.getAnalyticPressureRegionIV() 

    def getAnalyticPressureRegionIV(self):
        return self.getAnalyticPressureRegionIVByNewton()

    def getAnalyticPressureRegionIVByNewton(self, x0=1):
        """
        x0 : the guess initial value to be applied in Newton method
        """
        return so.newton(self.analyticPressureRegionIV,x0)

    def getPressureRegionV(self):
        return self.PR

    ################
    ### Density  ###
    ################
    def getDensityRegionI(self):
        return self.RHOL

    def getAnalyticDensityRegionII(self, x,t):
        # (10.45), Wesseling P.
        gamma = self.GAMMA
        rhoI = self.RHOL
        pI = self.getPressureRegionI()
        pII = self.getAnalyticPressureRegionII(x, t)
        return rhoI*(pII/pI)**(1.0/gamma)

    def getAnalyticDensityRegionIII(self):
        # P410, Wesseling P.
        rhoI = self.getDensityRegionI()
        pI = self.getPressureRegionI()
        pIII = self.getAnalyticPressureRegionIII()
        return rhoI*(pIII/pI)**(1.0/self.GAMMA)

    def getAnalyticDensityRegionIV(self):
        # P410, Wesseling P.
        alpha = self.ALPHA
        pIV = self.getAnalyticPressureRegionIV()
        pV = self.getPressureRegionV()
        p = pIV/pV
        rhoV = self.getDensityRegionV()
        return rhoV*(1.0+alpha*p)/(alpha+p)

    def getDensityRegionV(self):
        return self.RHOR 

    def getCESESolution(self):
        return self.solution

    def calCESESolution(self, initcondition, mesh, ceseparameters):
        return self.solution

