#!/usr/bin/env python2.6
# -*- coding: UTF-8 -*-
#
# Copyright (C) 2010 Yung-Yu Chen <yyc@solvcon.net>.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

"""
Run with ./go submit pvtk --npart=3 --batch=OscGlenn --compress-nodelist
--use-mpi.  Environmental variables are used to control detail behaviors of
this simulation/arrangement:

- CMPR specifies compressor used to output VTU files ('gz' or '').
- ALTDIR specifies where to save the PVTU files.  Use absolute path.
- ALTSYM specifies the symbolic link to the alternate PVTK directory.  Use
  relative path to the basedir.
- NOSAVE turns off saving.
"""

import os
os.environ['SOLVCON_LOGFILE'] = 'solvcon.log'
from solvcon.batch import Torque
from solvcon.kerpak import euler
from solvcon.anchor import VtkAnchor

################################################################################
# Customized abstraction for Glenn cluster at OSC.
################################################################################
class OscGlenn(Torque):
    """
    Abstraction of the Torque installed on the Glenn cluster at OSC.
    """
    @property
    def _hostfile(self):
        import os
        return os.path.join(self.jobdir, self.jobname+'.hostfile')
    def get_extra_envars(self):
        import os
        items = list()
        for key in 'CMPR', 'ALTDIR', 'ALTSYM', 'NOSAVE':
            if os.environ.get(key, None) is not None:
                items.append('%s=%s' % (key, os.environ[key]))
        return items
    @property
    def str_prerun(self):
        import os
        from solvcon.conf import env
        ops, args = env.command.opargs
        msgs = [super(OscGlenn, self).str_prerun]
        msgs.extend(['export %s' % item for item in self.get_extra_envars()])
        if self.use_mpi:
            msgs.extend([
                'module unload mpi mpi2',
                'module load mvapich2-1.5-gnu',
            ])
            msgs.append('%s %s \\\n %s' % (
                env.get_entry_point(),
                'mpi --compress-nodelist' if ops.compress_nodelist else 'mpi',
                self._hostfile,
            ))
        return '\n'.join(msgs)
    def build_mpi_runner(self):
        return self.build_mpi_runner_mpirun()
    def build_mpi_runner_mpiexec(self):
        from solvcon.conf import env
        ops, args = env.command.opargs
        cmds = ['SOLVCON_MPI=1', 'mpiexec', '-n %d'%(ops.npart+1)]
        if ops.compress_nodelist:
            cmds.append('-pernode')
        return ' '.join(cmds)
    def build_mpi_runner_mpirun(self):
        from solvcon.conf import env
        ops, args = env.command.opargs
        cmds = ['mpirun_rsh', '-rsh',
            '-np %d'%(ops.npart+1), '\\\n',
            '-hostfile %s' % self._hostfile, '\\\n',
            'LD_PRELOAD=libmpich.so',
            'PBS_NODEFILE=$PBS_NODEFILE', 'SOLVCON_MPI=1', '\\\n',
            ' \\\n '.join(self.get_extra_envars()), '\\\n',
        ]
        return ' '.join(cmds)
    @property
    def str_postrun(self):
        import sys, os
        newstr = [super(OscGlenn, self).str_postrun]
        newstr.extend([
            'mpiexec -comm none -pernode killall %s' % \
            os.path.basename(sys.executable),
        ])
        return '\n'.join(newstr)
class OscGlennGbE(OscGlenn):
    pass
class OscGlennIB(OscGlenn):
    def nodelist(self):
        ndlst = super(OscGlennIB, self).nodelist()
        for node in ndlst:
            if '-ib-' not in node.name:
                node.name = node.name[:3] + '-ib-' + node.name[3:]
        return ndlst

################################################################################
# Visualization.
################################################################################

class CutVtkAnchor(VtkAnchor):
    def process(self, istep):
        self._aggregate()
        self.svr.ust.GetCellData().SetActiveScalars('p')
        usp = self._vtk_c2p(self.svr.ust)
        fts = list()
        #cut = self._vtk_cut(usp, (0,0,1), (0,0,1))
        #cnr = self._vtk_contour_range(cut, 50, 30000, 300000)
        #cnr.Update()
        #fts.append(cnr)
        fts.append(self._vtk_cut(usp, (0,0,1.e-6), (0,0,1)))
        fts[-1].Update()
        fts.append(self._vtk_cut(usp, (0,0,4.5), (0,1,0)))
        fts[-1].Update()
        #fts.append(self._vtk_contour_value(usp, 0, 300000))
        #fts[-1].Update()
        lpd = self._vtk_lump_poly(*fts)
        self._vtk_write_poly(lpd, self.vtkfn)

################################################################################
# Basic configuration.
################################################################################
def vtkw_base(casename=None, meshname=None, psteps=None, ssteps=None,
    gamma=None, rhoi=None, prei=None, Mi=None, rhoj=None, prej=None, Mj=None,
    **kw):
    """
    Fundamental configuration of the simulation and return the case object.

    @return: the created Case object.
    @rtype: solvcon.case.BlockCase
    """
    import os
    from numpy import sqrt
    from solvcon.helper import search_in_parents
    from solvcon.conf import env
    from solvcon.boundcond import bctregy
    from solvcon.solver import ALMOST_ZERO
    from solvcon import hook, anchor
    from solvcon.kerpak import cese
    # set flow properties (fp).
    fpi = {'gamma': gamma, 'rho': rhoi, 'p': prei, 'v2': 0.0, 'v3': 0.0}
    fpi['v1'] = Mi*sqrt(gamma*fpi['p']/fpi['rho'])
    fpj = {'gamma': gamma, 'rho': rhoj, 'p': prej, 'v1': 0.0, 'v2': 0.0}
    fpj['v3'] = Mj*sqrt(gamma*fpj['p']/fpj['rho'])
    # set up BCs.
    bcmap = {
        'jet': (bctregy.EulerInlet, fpj,),
        'upstream': (bctregy.EulerInlet, fpi,),
        'downstream': (bctregy.CeseNonrefl, {},),
        'side': (bctregy.CeseNonrefl, {},),
        'top': (bctregy.CeseNonrefl, {},),
        'wall': (bctregy.EulerWall, {},),
    }
    # set up case.
    basedir = os.path.abspath(os.getcwd())
    if os.path.basename(basedir) != 'result':   # for submitted job.
        basedir = os.path.join(basedir, 'result')
    meshdir = search_in_parents(os.getcwd(), 'mesh')
    cse = euler.EulerCase(basedir=basedir, rootdir=env.projdir,
        basefn=casename, meshfn=os.path.join(env.find_scdata_mesh(), meshname),
        bcmap=bcmap, **kw)
    # statistical anchors for solvers.
    for name in 'Runtime', 'March', 'Tpool':
        cse.runhooks.append(getattr(anchor, name+'StatAnchor'))
    # informative hooks.
    cse.runhooks.append(hook.BlockInfoHook)
    cse.runhooks.append(hook.ProgressHook, psteps=psteps,
        linewidth=ssteps/psteps)
    cse.runhooks.append(cese.CflHook, fullstop=False, psteps=ssteps,
        cflmax=10.0, linewidth=ssteps/psteps)
    cse.runhooks.append(cese.ConvergeHook, psteps=ssteps)
    # initializer anchors..
    cse.runhooks.append(anchor.FillAnchor, keys=('soln',), value=ALMOST_ZERO)
    cse.runhooks.append(anchor.FillAnchor, keys=('dsoln',), value=0)
    cse.runhooks.append(euler.UniformIAnchor, **fpi)
    # analyzing/output anchors and hooks.
    cse.runhooks.append(euler.EulerOAnchor)
    if not os.environ.get('NOSAVE', False):
        cse.runhooks.append(hook.PMarchSave, anames=[
                ('soln', False, -5),
                ('rho', True, 0),
                ('p', True, 0),
                ('T', True, 0),
                ('ke', True, 0),
                ('M', True, 0),
                ('sch', True, 0),
                ('v', True, 0.5),
            ], fpdtype='float64', psteps=ssteps,
            compressor=os.environ.get('CMPR', 'gz'),
            altdir=os.environ.get('ALTDIR', ''),
            altsym=os.environ.get('ALTSYM', ''))
        cse.runhooks.append(hook.PVtkHook, anames=[
                ('soln', False, -5),
                ('rho', True, 0),
                ('p', True, 0),
                ('T', True, 0),
                ('ke', True, 0),
                ('M', True, 0),
                ('sch', True, 0),
                ('v', True, 0.5),
            ], ankcls=CutVtkAnchor, psteps=ssteps,
            altdir=os.environ.get('ALTDIR', ''),
            altsym=os.environ.get('ALTSYM', ''))
    return cse

################################################################################
# The arrangement.
################################################################################
@euler.EulerCase.register_arrangement
def vtkw(casename, **kw):
    """
    Resources are set to use olddual (dual dual-core Opteron) nodes.
    """
    kw.setdefault('resources', {
        'ppn=4:olddual:pvfs': None,
        'walltime': '00:10:00',
    })
    return vtkw_base(casename=casename, meshname='sjcf5v1m_m500mm.neu.gz',
        gamma=1.4, Mi=1.98, rhoi=0.86, prei=41.8e3, Mj=1.02, rhoj=6.64,
        prej=476.e3, diffname='tau', tauname='scale', taumin=0.1, tauscale=0.9,
        rkillfn='', time_increment=2.5e-4, steps_run=10, ssteps=10, psteps=1,
        **kw)

################################################################################
# Invoke SOLVCON workflow.
################################################################################
if __name__ == '__main__':
    import solvcon
    solvcon.go()
