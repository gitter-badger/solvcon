#!/usr/bin/env python2.6
# -*- coding: UTF-8 -*-
#
# Copyright (C) 2010 Yung-Yu Chen <yyc@solvcon.net>.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

"""
Example for using the Glenn cluster at Ohio Supercomputer Center (OSC).
SOLVCON models the batch systems in solvcon.batch, and by subclassing
solvcon.batch.Batch, users can customize the abstraction.  SOLVCON has provided
an abstraction for Torque/OpenPBS in solvcon.batch.Torque.  If your cluster
also uses Torque, you can subclass Torque rather than Batch to save time.

In this file, OscGlenn, OscGlennGbE and OscGlennIB are provided.  The reason to
have OscGlennGbE and OscGlennIB is for SOLVCON to use socket to bind the TCP/IP
layer of either GbE or IB.  If MPI communication layer is used by specifying
--use-mpi, all the three batches should work equivelently.

For serial simulation, execute ./go run.  To submit to the PBS/Torque at OSC
Glenn cluster, execute ./go submit osc --npart=2 --batch=OscGlenn
--compress-nodelist --use-mpi.  The name of arrangement cannot be omitted when
it is submit.  --npart specifies how many sub-domains to be decomposed to,
--batch specifies the batch system to be used, --compress-nodelist indicates
using all processors of a node, and --use-mpi specifies to use MPI library for
communication.  You can also add -l 'resource string' while submitting the job.
Note the resource requesting must match --compress-nodelist.  This arrangement
by default use the olddual partition.
"""

import os
os.environ['SOLVCON_LOGFILE'] = 'solvcon.log'
from solvcon.batch import Torque
from solvcon.kerpak import euler

################################################################################
# Customized abstraction for Glenn cluster at OSC.
################################################################################
class OscGlenn(Torque):
    """
    Abstraction of the Torque installed on the Glenn cluster at OSC.
    """
    @property
    def _hostfile(self):
        import os
        return os.path.join(self.jobdir, self.jobname+'.hostfile')
    @property
    def str_prerun(self):
        import os
        from solvcon.conf import env
        ops, args = env.command.opargs
        msgs = [super(OscGlenn, self).str_prerun]
        if self.use_mpi:
            msgs.extend([
                'module unload mpi mpi2',
                'module load mvapich2-1.5-gnu',
            ])
            msgs.append('%s %s \\\n %s' % (
                env.get_entry_point(),
                'mpi --compress-nodelist' if ops.compress_nodelist else 'mpi',
                self._hostfile,
            ))
        return '\n'.join(msgs)
    def build_mpi_runner(self):
        return self.build_mpi_runner_mpirun()
    def build_mpi_runner_mpiexec(self):
        from solvcon.conf import env
        ops, args = env.command.opargs
        cmds = ['SOLVCON_MPI=1', 'mpiexec', '-n %d'%(ops.npart+1)]
        if ops.compress_nodelist:
            cmds.append('-pernode')
        return ' '.join(cmds)
    def build_mpi_runner_mpirun(self):
        from solvcon.conf import env
        ops, args = env.command.opargs
        cmds = ['mpirun_rsh', '-rsh',
            '-np %d'%(ops.npart+1), '\\\n',
            '-hostfile %s' % self._hostfile, '\\\n',
            'LD_PRELOAD=libmpich.so',
            'PBS_NODEFILE=$PBS_NODEFILE', 'SOLVCON_MPI=1', '\\\n',
        ]
        return ' '.join(cmds)
    @property
    def str_postrun(self):
        import sys, os
        newstr = [super(OscGlenn, self).str_postrun]
        newstr.extend([
            'mpiexec -comm none -pernode killall %s' % \
            os.path.basename(sys.executable),
        ])
        return '\n'.join(newstr)
class OscGlennGbE(OscGlenn):
    pass
class OscGlennIB(OscGlenn):
    def nodelist(self):
        ndlst = super(OscGlennIB, self).nodelist()
        for node in ndlst:
            if '-ib-' not in node.name:
                node.name = node.name[:3] + '-ib-' + node.name[3:]
        return ndlst

################################################################################
# Basic configuration.
################################################################################
def pvtk_base(casename=None, meshname=None, psteps=None, ssteps=None,
    gamma=None, rhoi=None, prei=None, Mi=None, rhoj=None, prej=None, Mj=None,
    do_save=True, **kw):
    """
    Fundamental configuration of the simulation and return the case object.

    @return: the created Case object.
    @rtype: solvcon.case.BlockCase
    """
    import os
    from numpy import sqrt
    from solvcon.helper import search_in_parents
    from solvcon.conf import env
    from solvcon.boundcond import bctregy
    from solvcon.solver import ALMOST_ZERO
    from solvcon import hook, anchor
    from solvcon.kerpak import cese
    # set flow properties (fp).
    fpi = {'gamma': gamma, 'rho': rhoi, 'p': prei, 'v2': 0.0, 'v3': 0.0}
    fpi['v1'] = Mi*sqrt(gamma*fpi['p']/fpi['rho'])
    fpj = {'gamma': gamma, 'rho': rhoj, 'p': prej, 'v1': 0.0, 'v2': 0.0}
    fpj['v3'] = Mj*sqrt(gamma*fpj['p']/fpj['rho'])
    # set up BCs.
    bcmap = {
        'jet': (bctregy.EulerInlet, fpj,),
        'upstream': (bctregy.EulerInlet, fpi,),
        'downstream': (bctregy.CeseNonrefl, {},),
        'side': (bctregy.CeseNonrefl, {},),
        'top': (bctregy.CeseNonrefl, {},),
        'wall': (bctregy.EulerWall, {},),
    }
    # set up case.
    basedir = os.path.abspath(os.getcwd())
    if os.path.basename(basedir) != 'result':   # for submitted job.
        basedir = os.path.join(basedir, 'result')
    meshdir = search_in_parents(os.getcwd(), 'mesh')
    cse = euler.EulerCase(basedir=basedir, rootdir=env.projdir,
        basefn=casename, meshfn=os.path.join(meshdir, meshname),
        bcmap=bcmap, **kw)
    # statistical anchors for solvers.
    for name in 'Runtime', 'March', 'Tpool':
        cse.runhooks.append(getattr(anchor, name+'StatAnchor'))
    # informative hooks.
    cse.runhooks.append(hook.BlockInfoHook)
    cse.runhooks.append(hook.ProgressHook, psteps=psteps,
        linewidth=ssteps/psteps)
    cse.runhooks.append(cese.CflHook, fullstop=False, psteps=ssteps,
        cflmax=10.0, linewidth=ssteps/psteps)
    cse.runhooks.append(cese.ConvergeHook, psteps=ssteps)
    # initializer anchors..
    cse.runhooks.append(anchor.FillAnchor, keys=('soln',), value=ALMOST_ZERO)
    cse.runhooks.append(anchor.FillAnchor, keys=('dsoln',), value=0)
    cse.runhooks.append(euler.UniformIAnchor, **fpi)
    # analyzing/output anchors and hooks.
    cse.runhooks.append(euler.EulerOAnchor)
    if do_save:
        cse.runhooks.append(hook.PMarchSave, anames=[
            ('soln', False, -5),
            ('rho', True, 0),
            ('p', True, 0),
            ('T', True, 0),
            ('ke', True, 0),
            ('M', True, 0),
            ('sch', True, 0),
            ('v', True, 0.5),
        ], fpdtype='float64', psteps=ssteps)
    return cse

################################################################################
# The arrangement.
################################################################################
@euler.EulerCase.register_arrangement
def pvtk(casename, **kw):
    """
    Resources are set to use olddual (dual dual-core Opteron) nodes.
    """
    kw.setdefault('resources', {
        'ppn=4:olddual:pvfs': None,
        'walltime': '00:10:00',
    })
    return pvtk_base(casename=casename, meshname='sjcf4m1m_h50mm_p3.dom',
        gamma=1.4, Mi=1.98, rhoi=0.86, prei=41.8e3, Mj=1.02, rhoj=6.64,
        prej=476.e3, diffname='tau', tauname='scale', taumin=0.1, tauscale=0.9,
        rkillfn='', time_increment=3.e-5, steps_run=10, ssteps=10, psteps=1,
        do_save=False, **kw)

################################################################################
# Invoke SOLVCON workflow.
################################################################################
if __name__ == '__main__':
    import solvcon
    solvcon.go()
