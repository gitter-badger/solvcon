#!/usr/bin/env python2.6
# -*- coding: UTF-8 -*-
#
# Copyright (C) 2010-2011 Yung-Yu Chen <yyc@solvcon.net>.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

"""
Experimental.  Not guaranteed to work.

The periodic BC can be used as a through BC.

The arrangement through can be run by simply executing ./go run.
"""

from solvcon.hook import BlockHook
from solvcon.anchor import Anchor
from solvcon.kerpak.cese import ProbeHook
from solvcon.kerpak import gasdyn

# TODO: Glue should go to solvcon.boundcond
class Glue(object):
    """
    Glue two boundary conditions which are considered to be collocated.

    @cvar CACHE_KEYS_ENABLER: names of arrays whose original values to be
        cached when the glue is enabled.
    @ctype CACHE_KEYS_ENABLER: tuple
    @ivar sbc: source BC object.
    @itype sbc: solvcon.boundcond.BC
    @ivar reciprocal: the glue object on the other side.
    @itype reciprocal: Glue
    @ivar ref: a reference point for matching bounding faces.
    @itype ref: numpy.ndarray
    @ivar cache: cache for mesh data.
    @itype cache: dict
    @ivar scls: source cell list shifted by ngstcell.
    @itype scls: numpy.ndarray
    @ivar dcls: destination cell list shifted by ngstcell.
    @itype dcls: numpy.ndarray
    """

    CACHE_KEYS_ENABLER = ('cltpn', 'clgrp', 'clvol', 'clcnd')

    def __init__(self, sbc, dbc, ref=None, reciprocal=None):
        """
        The constructor will create a PAIR of Glue objects attached to the
        input source BC (sbc) and destination BC (dbc) objects.  Each Glue
        object in the pair is the reciprocal of the other.  The constructor
        DOES NOT modify associated BC or BlockSolver objects except setting
        BC objects' glue property to self.  If no reference point is given
        through ref keyword, a random reference point is generated for sorting
        boundary faces to be glued.

        @param sbc: source BC object.
        @type sbc: solvcon.boundcond.BC
        @param dbc: destination BC object.
        @type dbc: solvcon.boundcond.BC
        @keyword ref: a reference point for matching bounding faces.
        @type ref: numpy.ndarray
        @keyword reciprocal: the glue object on the other side.
        @type reciprocal: Glue
        """
        from random import random
        from numpy import array
        svr = sbc.svr
        ngstface = svr.ngstface
        ngstcell = svr.ngstcell
        ndim = svr.ndim
        fpdtype = svr.fpdtype
        # set source BC object and cache container.
        self.sbc = sbc
        self.cache = dict()
        # calculate and set a reference point and use it to sort faces.
        if ref is None:
            ref = array([random() for it in range(ndim)], dtype=fpdtype)
        assert len(ref) == ndim
        self.ref = ref
        # calculate and set cell lists.
        self.scls = svr.fccls[self.__sortfcs(sbc,ref),1] + ngstcell
        self.dcls = svr.fccls[self.__sortfcs(dbc,ref),0] + ngstcell
        assert (self.scls<ngstcell).all()
        assert (self.dcls>=ngstcell).all()
        # set properties to source BC.
        assert hasattr(sbc, 'glue')
        sbc.glue = self
        # create and set reciprocal if self is the first in a pair.
        if reciprocal is None:
            self.reciprocal = Glue(dbc, sbc, ref=ref, reciprocal=self)
        else:
            assert isinstance(reciprocal, Glue)
            self.reciprocal = reciprocal

    @staticmethod
    def __sortfcs(bc, ref):
        """
        Get the sorted face list of a BC object according to the reference
        point.

        @param bc: a BC object.
        @type bc: solvcon.boundcond.BC
        @param ref: reference point.
        @type ref: numpy.ndarray
        @return: sorted face indices shifted by ngstface.
        @rtype: numpy.ndarray
        """
        cnd = bc.svr.fccnd[bc.facn[:,0]+bc.svr.ngstface,:]
        dist = ((cnd - ref)**2).sum(axis=1)
        return bc.facn[dist.argsort(),0]+bc.svr.ngstface

    def enable(self, *args, **kw):
        """
        Enable this glue by setting ghost information from interior and store
        original values in a cache.  Arguments are the keys of arrays to be
        cached.

        @keyword with_default: use CACHE_KEYS_ENABLER anyway.  Default True.
        @type with_default: bool
        @return: nothing
        """
        keys = list(args)
        if args and kw.get('with_default', True):
            keys.extend(self.CACHE_KEYS_ENABLER)
        for key in keys:
            arr = getattr(self.sbc.svr, key)
            self.cache[key] = arr[self.scls].copy()
            self.take(key)

    def disable(self, *args, **kw):
        """
        Disable this glue by restoring ghost information from cached values.
        Arguments are the keys of cached arrays.

        @keyword with_default: use CACHE_KEYS_ENABLER anyway.  Default True.
        @type with_default: bool
        @return: nothing
        """
        keys = list(args)
        if args and kw.get('with_default', True):
            keys.extend(self.CACHE_KEYS_ENABLER)
        for key in keys:
            arr = getattr(self.sbc.svr, key)
            arr[self.scls] = self.cache[key]

    def take(self, key):
        """
        Take array values from interior cells to ghost cells.

        @param key: the name of the array.
        @type key: str
        @return: nothing
        """
        arr = getattr(self.sbc.svr, key)
        arr[self.scls] = arr[self.dcls]

# TODO: GlueAnchor should go to solvcon.kerpak.cuse
class GlueAnchor(Anchor):
    """
    Use Glue class to glue specified BC objects of a solver object.  The class
    is only valid for CuseSolver.

    @ivar bcpairs: a sequence of 2-tuples for BC object pairs to be glued.
    @itype bcpairs: sequence
    """
    def __init__(self, svr, **kw):
        from solvcon.kerpak.cuse import CuseSolver
        assert isinstance(svr, CuseSolver)
        self.bcpairs = kw.pop('bcpairs')
        super(GlueAnchor, self).__init__(svr, **kw)

    def _attach_glue(self):
        """
        Attach Glue objects to specified BC object pairs.

        @return: nothing
        """
        nmbc = dict([(bc.name, bc) for bc in self.svr.bclist])
        for key0, key1 in self.bcpairs:
            assert nmbc[key0].glue is None
            assert nmbc[key1].glue is None
            Glue(nmbc[key0], nmbc[key1])

    def _detach_glue(self):
        """
        Detach Glue objects from specified BC object pairs.

        @return: nothing
        """
        nmbc = dict([(bc.name, bc) for bc in self.svr.bclist])
        for key0, key1 in self.bcpairs:
            assert isinstance(nmbc[key0].glue, Glue)
            assert isinstance(nmbc[key1].glue, Glue)
            nmbc[key0].glue = None
            nmbc[key1].glue = None

    def _enable_glue(self, check=True):
        """
        Enable the gluing mechanism by calling Glue.enable() for specified BC
        object pairs.

        @keyword check: check Glue object or not.  Default True.
        @type check: bool
        @return: nothing
        """
        from ctypes import byref
        svr = self.svr
        if check:
            self._attach_glue()
        nmbc = dict([(bc.name, bc) for bc in svr.bclist])
        for keys in self.bcpairs:
            for key in keys:
                nmbc[key].glue.enable('cecnd')
        svr._clib_cuse_c.prepare_ce(byref(svr.exd))
        svr._clib_cuse_c.prepare_sf(byref(svr.exd))
        if svr.scu: svr.cumgr.arr_to_gpu()

    def _disable_glue(self, check=True):
        """
        Disable the gluing mechanism by calling Glue.disable() for specified BC
        object pairs.

        @keyword check: check Glue object or not.  Default True.
        @type check: bool
        @return: nothing
        """
        from ctypes import byref
        svr = self.svr
        nmbc = dict([(bc.name, bc) for bc in svr.bclist])
        for keys in self.bcpairs:
            for key in keys:
                nmbc[key].glue.disable('cecnd')
        svr._clib_cuse_c.prepare_ce(byref(svr.exd))
        svr._clib_cuse_c.prepare_sf(byref(svr.exd))
        if svr.scu: svr.cumgr.arr_to_gpu()
        if check:
            self._detach_glue()

# TODO: gluetake() should go to solvcon.kerpak.cuse.CuseBC
class GasdynOpenWall(gasdyn.GasdynWall):
    def __init__(self, **kw):
        from numpy import empty
        super(GasdynOpenWall, self).__init__(**kw)
        self.glue = None
    def cloneTo(self, another):
        super(GasdynOpenWall, self).cloneTo(another)
        another.glue = None
    def gluetake(self, key):
        """
        Use the attached Glue object to update the array specified by key.

        @param key: array name.
        @type key: str
        @return: nothing
        """
        svr = self.svr
        if svr.scu: svr.cumgr.arr_from_gpu(key)
        self.glue.take(key)
        if svr.scu: svr.cumgr.arr_to_gpu(key)

    def soln(self):
        if self.glue is None:
            super(GasdynOpenWall, self).soln()
        else:
            self.gluetake('soln')
    def dsoln(self):
        if self.glue is None:
            super(GasdynOpenWall, self).dsoln()
        else:
            self.gluetake('dsoln')

class OpenwallAnchor(GlueAnchor):
    def __init__(self, svr, **kw):
        self.estep = float(kw.pop('estep'))
        super(OpenwallAnchor, self).__init__(svr, **kw)
    def prefull(self):
        svr = self.svr
        if svr.step_global == self.estep:
            self._enable_glue()

class ExactMovingShockHook(BlockHook):
    def __init__(self, cse, **kw):
        self.ms = kw['ms']
        self.pressure = kw['pressure']
        self.density = kw['density']
        super(ExactMovingShockHook, self).__init__(cse, **kw)
    def preloop(self):
        tem = self.ms.calc_temperature(self.pressure, self.density)
        self.info('Properties behind shock (exact):\n')
        self.info('  rho1, rho2       = %g, %g (kg/m^3)\n' % (
            self.density, self.density*self.ms.ratio_rho))
        self.info('  p1, p2           = %g, %g (Pa)\n' % (
            self.pressure, self.pressure*self.ms.ratio_p))
        self.info('  T1, T2           = %g, %g (K)\n' % (
            tem, tem*self.ms.ratio_T))
        self.info('  Ms (M1), M2, M2p = %g, %g, %g\n' % (
            self.ms.Ms, self.ms.M2, self.ms.M2p))
        self.info('  vs, v            = %g, %g (m/s)\n' % tuple(
            self.ms.calc_speeds(self.pressure, self.density)))
    postloop = preloop

def mesher(cse):
    import os
    from solvcon.helper import Cubit
    cmds = open(os.path.join(os.path.dirname(__file__),
        'through.tmpl')).read() % cse.io.meshfn
    cmds = [cmd.strip() for cmd in cmds.strip().split('\n')]
    gn = Cubit(cmds, 2)()
    return gn.toblock(bcname_mapper=cse.condition.bcmap)

def through_base(casename=None, meshname=None,
    gamma=None, gasconst=None, density=None, pressure=None, Ms=None,
    psteps=None, ssteps=None, **kw
):
    """
    Fundamental configuration of the simulation and return the case object.

    @return: the created Case object.
    @rtype: solvcon.case.BlockCase
    """
    import os
    from numpy import pi, array, sin, cos, sqrt
    from solvcon.conf import env
    from solvcon.boundcond import bctregy
    from solvcon.solver import ALMOST_ZERO
    from solvcon import hook, anchor
    from solvcon.kerpak import cuse
    # set flow properties (fp).
    ms = gasdyn.MovingShock(ga=gamma, Ms=Ms, gasconst=gasconst)
    vs, v = ms.calc_speeds(pressure, density)
    fpi = {
        'gamma': gamma, 'rho': density, 'v2': 0.0, 'v3': 0.0, 'p': pressure,
    }
    fpi['v1'] = 0.0
    fpb = fpi.copy()
    fpb['p'] = pressure*ms.ratio_p
    fpb['rho'] = density*ms.ratio_rho
    fpb['v1'] = v
    # set up BCs.
    bcmap = {
        'upper': (bctregy.GasdynWall, {},),
        'left': (bctregy.GasdynInlet, fpb,),
        'right': (bctregy.CuseNonrefl, {},),
        'lower': (bctregy.GasdynWall, {},),
        'iupperu': (bctregy.GasdynOpenWall, {},),
        'iupperd': (bctregy.GasdynOpenWall, {},),
        'ileftu': (bctregy.GasdynOpenWall, {},),
        'ileftd': (bctregy.GasdynOpenWall, {},),
        'irightu': (bctregy.GasdynOpenWall, {},),
        'irightd': (bctregy.GasdynOpenWall, {},),
        'iloweru': (bctregy.GasdynOpenWall, {},),
        'ilowerd': (bctregy.GasdynOpenWall, {},),
    }
    # set up case.
    basedir = os.path.abspath(os.path.join(os.getcwd(), 'result'))
    cse = gasdyn.GasdynCase(basedir=basedir, rootdir=env.projdir,
        basefn=casename, meshfn=meshname, mesher=mesher, bcmap=bcmap, **kw)
    # anchors for solvers.
    for key in 'Runtime', 'March', 'Tpool':
        cse.runhooks.append(getattr(anchor, key+'StatAnchor'))
    # informative.
    cse.runhooks.append(hook.ProgressHook,
        psteps=psteps, linewidth=ssteps/psteps,
    )
    cse.runhooks.append(cuse.CflHook, fullstop=False, psteps=ssteps,
        cflmax=10.0, linewidth=ssteps/psteps,
    )
    cse.runhooks.append(cuse.ConvergeHook, psteps=ssteps)
    cse.runhooks.append(hook.SplitMarker)
    cse.runhooks.append(hook.GroupMarker)
    cse.runhooks.append(hook.BlockInfoHook, psteps=ssteps, show_bclist=True)
    # initializer.
    cse.runhooks.append(anchor.FillAnchor, keys=('soln',), value=ALMOST_ZERO)
    cse.runhooks.append(anchor.FillAnchor, keys=('dsoln',), value=0)
    cse.runhooks.append(gasdyn.UniformIAnchor, **fpi)
    # repture.
    cse.runhooks.append(OpenwallAnchor, estep=0, bcpairs=(
        ('ileftu', 'ileftd'),
        ('iloweru', 'ilowerd'),
        ('irightu', 'irightd'),
        ('iupperu', 'iupperd'),
    ))
    # post processing.
    ## collect variables.
    varlist = list()
    for var in ['soln', 'dsoln']:
        varlist.append((var, {'inder': False, 'consider_ghost': True}))
    for var in ['rho', 'p', 'T', 'ke', 'M', 'sch', 'v']:
        varlist.append((var, {'inder': True, 'consider_ghost': True}))
    cse.runhooks.append(hook.CollectHook, psteps=ssteps, varlist=varlist)
    ## execution order is reversed for postloop.
    cse.runhooks.append(ExactMovingShockHook,
        ms=ms, density=density, pressure=pressure)
    cse.runhooks.append(gasdyn.GasdynOAnchor, gasconst=gasconst, rsteps=ssteps)
    ## output.
    cse.runhooks.append(hook.MarchSave,
        psteps=ssteps, binary=True, cache_grid=True)
    return cse

if __name__ == '__main__':
    cse = through_base('through_quad',
        gamma=1.4, gasconst=286.9, density=1.205, pressure=101325., Ms=3.0,
        meshname='map', time_increment=1.5e-4, steps_run=10,
        ssteps=1, psteps=1)
    cse.init()
    cse.run()
    cse.cleanup()
    cse = through_base('through_tri',
        gamma=1.4, gasconst=286.9, density=1.205, pressure=101325., Ms=3.0,
        meshname='tridelaunay', time_increment=5.e-5, steps_run=30,
        ssteps=1, psteps=1)
    cse.init()
    cse.run()
    cse.cleanup()
