#!/usr/bin/env python2.6
# -*- coding: UTF-8 -*-
#
# Copyright (C) 2010-2011 Yung-Yu Chen <yyc@solvcon.net>.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

"""
Experimental.  Not guaranteed to work.

The periodic BC can be used as a through BC.

The arrangement through can be run by simply executing ./go run.
"""

from solvcon.hook import BlockHook
from solvcon.anchor import Anchor
from solvcon.kerpak.cese import ProbeHook
from solvcon.kerpak import gasdyn

class ExactMovingShockHook(BlockHook):
    def __init__(self, cse, **kw):
        self.ms = kw['ms']
        self.pressure = kw['pressure']
        self.density = kw['density']
        super(ExactMovingShockHook, self).__init__(cse, **kw)
    def preloop(self):
        tem = self.ms.calc_temperature(self.pressure, self.density)
        self.info('Properties behind shock (exact):\n')
        self.info('  rho1, rho2       = %g, %g (kg/m^3)\n' % (
            self.density, self.density*self.ms.ratio_rho))
        self.info('  p1, p2           = %g, %g (Pa)\n' % (
            self.pressure, self.pressure*self.ms.ratio_p))
        self.info('  T1, T2           = %g, %g (K)\n' % (
            tem, tem*self.ms.ratio_T))
        self.info('  Ms (M1), M2, M2p = %g, %g, %g\n' % (
            self.ms.Ms, self.ms.M2, self.ms.M2p))
        self.info('  vs, v            = %g, %g (m/s)\n' % tuple(
            self.ms.calc_speeds(self.pressure, self.density)))
    postloop = preloop

def mesher(cse):
    import os
    from solvcon.helper import Cubit
    cmds = open(os.path.join(os.path.dirname(__file__),
        'through.tmpl')).read() % cse.io.meshfn
    cmds = [cmd.strip() for cmd in cmds.strip().split('\n')]
    gn = Cubit(cmds, 2)()
    return gn.toblock(bcname_mapper=cse.condition.bcmap)

class Glue(object):
    """
    Glue two boundary conditions which exactly collocate.

    @cvar CACHE_KEYS_ENABLER: names of arrays whose original values to be
        cached when the glue is enabled.
    @ctype CACHE_KEYS_ENABLER: tuple
    @ivar sbc: source BC object.
    @itype sbc: solvcon.boundcond.BC
    @ivar reciprocal: the glue object on the other side.
    @itype reciprocal: Glue
    @ivar ref: a reference point for matching bounding faces.
    @itype ref: numpy.ndarray
    @ivar cache: cache for mesh data.
    @itype cache: dict
    @ivar scls: source cell list.
    @itype scls: numpy.ndarray
    @ivar dcls: destination cell list.
    @itype dcls: numpy.ndarray
    """

    CACHE_KEYS_ENABLER = ('cltpn', 'clgrp', 'clvol', 'clcnd')

    def __init__(self, sbc, dbc, ref=None, reciprocal=None):
        """
        If no reference point is given through ref keyword, a random reference
        point is generated for sorting boundary faces to be glued.

        @param sbc: source BC object.
        @type sbc: solvcon.boundcond.BC
        @param dbc: destination BC object.
        @type dbc: solvcon.boundcond.BC
        @keyword ref: a reference point for matching bounding faces.
        @type ref: numpy.ndarray
        @keyword reciprocal: the glue object on the other side.
        @type reciprocal: Glue
        """
        from random import random
        from numpy import array
        blk = sbc.blk
        ngstcell = blk.ngstcell
        ndim = blk.ndim
        fpdtype = blk.fpdtype
        # set source BC object and cache container.
        self.sbc = sbc
        self.cache = dict()
        # calculate and set a reference point and use it to sort faces.
        if ref is None:
            self.ref = array([random() for it in range(ndim)], dtype=fpdtype)
        else:
            self.ref = ref
        assert len(self.ref) == ndim
        if reciprocal is None:
            self.sort(sbc, self.ref)
            self.sort(dbc, self.ref)
        # calculate and set cell lists.
        self.scls = blk.fccls[sbc.facn[:,0],1] + ngstcell
        self.dcls = blk.fccls[dbc.facn[:,0],0] + ngstcell
        assert (self.scls<ngstcell).all()
        assert (self.dcls>=ngstcell).all()
        # set properties to source BC.
        assert hasattr(sbc, 'glue')
        sbc.glue = self
        # create and set reciprocal if self is the first in a pair.
        if reciprocal is None:
            self.reciprocal = Glue(dbc, sbc, ref=self.ref, reciprocal=self)
        else:
            assert isinstance(reciprocal, Glue)
            self.reciprocal = reciprocal

    @staticmethod
    def sort(bc, ref):
        """
        Sort the face list of a BC object according to the reference
        point.

        @param bc: a BC object.
        @type bc: solvcon.boundcond.BC
        @return: nothing
        """
        fcs = bc.blk.fccnd[bc.facn[:,0],:]
        dist = ((fcs - ref)**2).sum(axis=1)
        slct = dist.argsort()
        bc.facn = bc.facn[slct]

    def enable(self, *args):
        """
        Enable this glue by setting ghost information from interior and store
        original values in a cache.  Arguments are the keys of arrays to be
        cached.

        @return: nothing
        """
        keys = args if args else self.CACHE_KEYS_ENABLER
        for key in keys:
            arr = getattr(self.sbc.svr, key)
            self.cache[key] = arr[self.scls].copy()
            self.take(key)
    def disable(self, *args):
        """
        Disable this glue by restoring ghost information from cached values.
        Arguments are the keys of cached arrays.

        @return: nothing
        """
        keys = args if args else self.CACHE_KEYS_ENABLER
        for key in keys:
            arr = getattr(self.sbc.svr, key)
            arr[self.scls] = self.cache[key]

    def take(self, key):
        """
        Take array values from interior cells to ghost cells.

        @param key: the name of the array.
        @type key: str
        @return: nothing
        """
        arr = getattr(self.sbc.svr, key)
        arr[self.scls] = arr[self.dcls]

class GasdynOpenWall(gasdyn.GasdynWall):
    def __init__(self, **kw):
        from numpy import empty
        super(GasdynOpenWall, self).__init__(**kw)
        self.glue = None

    def cloneTo(self, another):
        super(GasdynOpenWall, self).cloneTo(another)
        another.glue = self.glue

    def init(self, **kw):
        super(GasdynOpenWall, self).init(**kw)
        self.glue.enable()
        self.glue.enable('cecnd')
    def soln(self):
        svr = self.svr
        if svr.scu:
            svr.cumgr.arr_from_gpu('soln')
        self.glue.take('soln')
        if svr.scu:
            svr.cumgr.arr_to_gpu('soln')
    def dsoln(self):
        svr = self.svr
        if svr.scu:
            svr.cumgr.arr_from_gpu('dsoln')
        self.glue.take('dsoln')
        if svr.scu:
            svr.cumgr.arr_to_gpu('dsoln')

def match_open_wall(svr):
    nmidx = dict([(svr.bclist[idx].name, idx) for idx in
        range(len(svr.bclist))])
    for key0, key1 in (
        ('ileftu', 'ileftd'),
        ('iloweru', 'ilowerd'),
        ('irightu', 'irightd'),
        ('iupperu', 'iupperd'),
    ):
        ibc0 = nmidx[key0]
        ibc1 = nmidx[key1]
        pbc0 = svr.bclist[ibc0]
        pbc1 = svr.bclist[ibc1]
        Glue(pbc0, pbc1)

class RuptureAnchor(Anchor):
    def __init__(self, svr, **kw):
        self.estep = float(kw.pop('estep'))
        super(RuptureAnchor, self).__init__(svr, **kw)
    def prefull(self):
        from ctypes import byref
        svr = self.svr
        if svr.step_global == self.estep:
            match_open_wall(svr)
            for bc in svr.bclist:
                if isinstance(bc, GasdynOpenWall):
                    bc.init()
            svr._clib_cuse_c.prepare_ce(byref(svr.exd))
            svr._clib_cuse_c.prepare_sf(byref(svr.exd))
            if svr.scu: svr.cumgr.arr_to_gpu()

def through_base(casename=None, meshname=None,
    gamma=None, gasconst=None, density=None, pressure=None, Ms=None,
    psteps=None, ssteps=None, **kw
):
    """
    Fundamental configuration of the simulation and return the case object.

    @return: the created Case object.
    @rtype: solvcon.case.BlockCase
    """
    import os
    from numpy import pi, array, sin, cos, sqrt
    from solvcon.conf import env
    from solvcon.boundcond import bctregy
    from solvcon.solver import ALMOST_ZERO
    from solvcon import hook, anchor
    from solvcon.kerpak import cuse
    # set flow properties (fp).
    ms = gasdyn.MovingShock(ga=gamma, Ms=Ms, gasconst=gasconst)
    vs, v = ms.calc_speeds(pressure, density)
    fpi = {
        'gamma': gamma, 'rho': density, 'v2': 0.0, 'v3': 0.0, 'p': pressure,
    }
    fpi['v1'] = 0.0
    fpb = fpi.copy()
    fpb['p'] = pressure*ms.ratio_p
    fpb['rho'] = density*ms.ratio_rho
    fpb['v1'] = v
    # set up BCs.
    bcmap = {
        'upper': (bctregy.GasdynWall, {},),
        'left': (bctregy.GasdynInlet, fpb,),
        'right': (bctregy.CuseNonrefl, {},),
        'lower': (bctregy.GasdynWall, {},),
        'iupperu': (bctregy.GasdynOpenWall, {},),
        'iupperd': (bctregy.GasdynOpenWall, {},),
        'ileftu': (bctregy.GasdynOpenWall, {},),
        'ileftd': (bctregy.GasdynOpenWall, {},),
        'irightu': (bctregy.GasdynOpenWall, {},),
        'irightd': (bctregy.GasdynOpenWall, {},),
        'iloweru': (bctregy.GasdynOpenWall, {},),
        'ilowerd': (bctregy.GasdynOpenWall, {},),
    }
    # set up case.
    basedir = os.path.abspath(os.path.join(os.getcwd(), 'result'))
    cse = gasdyn.GasdynCase(basedir=basedir, rootdir=env.projdir,
        basefn=casename, meshfn=meshname, mesher=mesher,
        bcmap=bcmap, bcmod=match_open_wall, **kw)
    # anchors for solvers.
    for key in 'Runtime', 'March', 'Tpool':
        cse.runhooks.append(getattr(anchor, key+'StatAnchor'))
    # informative.
    cse.runhooks.append(hook.ProgressHook,
        psteps=psteps, linewidth=ssteps/psteps,
    )
    cse.runhooks.append(cuse.CflHook, fullstop=False, psteps=ssteps,
        cflmax=10.0, linewidth=ssteps/psteps,
    )
    cse.runhooks.append(cuse.ConvergeHook, psteps=ssteps)
    cse.runhooks.append(hook.SplitMarker)
    cse.runhooks.append(hook.GroupMarker)
    cse.runhooks.append(hook.BlockInfoHook, psteps=ssteps, show_bclist=True)
    # initializer.
    cse.runhooks.append(anchor.FillAnchor, keys=('soln',), value=ALMOST_ZERO)
    cse.runhooks.append(anchor.FillAnchor, keys=('dsoln',), value=0)
    cse.runhooks.append(gasdyn.UniformIAnchor, **fpi)
    # repture.
    #cse.runhooks.append(RuptureAnchor, estep=0)
    # post processing.
    ## collect variables.
    varlist = list()
    for var in ['soln', 'dsoln']:
        varlist.append((var, {'inder': False, 'consider_ghost': True}))
    for var in ['rho', 'p', 'T', 'ke', 'M', 'sch', 'v']:
        varlist.append((var, {'inder': True, 'consider_ghost': True}))
    cse.runhooks.append(hook.CollectHook, psteps=ssteps, varlist=varlist)
    ## execution order is reversed for postloop.
    cse.runhooks.append(ExactMovingShockHook,
        ms=ms, density=density, pressure=pressure)
    cse.runhooks.append(gasdyn.GasdynOAnchor, gasconst=gasconst, rsteps=ssteps)
    ## output.
    cse.runhooks.append(hook.MarchSave,
        psteps=ssteps, binary=True, cache_grid=True)
    return cse

if __name__ == '__main__':
    cse = through_base('through_quad',
        gamma=1.4, gasconst=286.9, density=1.205, pressure=101325., Ms=3.0,
        meshname='map', time_increment=1.5e-4, steps_run=10,
        ssteps=1, psteps=1)
    cse.init()
    cse.run()
    cse.cleanup()
    cse = through_base('through_tri',
        gamma=1.4, gasconst=286.9, density=1.205, pressure=101325., Ms=3.0,
        meshname='tridelaunay', time_increment=5.e-5, steps_run=30,
        ssteps=1, psteps=1)
    cse.init()
    cse.run()
    cse.cleanup()
