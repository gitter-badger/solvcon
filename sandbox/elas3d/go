#!/usr/bin/env python2.6
# -*- coding: UTF-8 -*-
#
# Copyright (C) 2010-2011 Yung-Yu Chen <yyc@solvcon.net>.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

"""
Convergence test for anisotropic elastic solver.
"""

import sys
sys.path.insert(0, '../..')
from solvcon.anchor import Anchor
from solvcon.hook import BlockHook
#from solvcon.kerpak import elastic
from solvcon.kerpak.cese import CesePeriodic
import elastic

###############################################################################
# Plane wave solution and initializer.
###############################################################################
class PlaneWaveSolution(object):
    def __init__(self, mtrl, idx, amp, ctr, wvec):
        from numpy import sqrt
        from numpy.linalg import eig
        assert len(ctr) == len(wvec)
        # calculate eigenvectors and eigenvalues.
        nml = wvec/sqrt((wvec**2).sum())
        jaco = mtrl.jacox*nml[0] + mtrl.jacoy*nml[1]
        if len(nml) == 3:
            jaco += mtrl.jacoz*nml[2]
        evl, evc = eig(jaco)
        srt = evl.argsort()
        evl = evl[srt[idx]]
        evc = evc[:,srt[idx]]
        # store data to self.
        self.amp = evc * (amp / sqrt((evc**2).sum()))
        self.ctr = ctr
        self.wvec = wvec
        self.afreq = evl * sqrt((wvec**2).sum())
        self.wsp = evl
    def __call__(self, svr, asol, adsol):
        from ctypes import byref, c_double
        from solvcon.dependency import doubleptr
        svr._clib_elastic.calc_planewave(
            byref(svr.exd),
            asol.ctypes.data_as(doubleptr),
            adsol.ctypes.data_as(doubleptr),
            self.amp.ctypes.data_as(doubleptr),
            self.ctr.ctypes.data_as(doubleptr),
            self.wvec.ctypes.data_as(doubleptr),
            c_double(self.afreq),
        )
class PlaneWaveAnchor(Anchor):
    def __init__(self, svr, **kw):
        self.planewaves = kw.pop('planewaves')
        super(PlaneWaveAnchor, self).__init__(svr, **kw)
    def _calculate(self, asol):
        for pw in self.planewaves:
            pw(self.svr, asol, self.adsol)
    def provide(self):
        from numpy import empty
        # plane wave solution.
        asol = self.svr.der['analytical'] = empty(
            (self.svr.ncell, self.svr.neq), dtype=self.svr.fpdtype)
        adsol = self.adsol = empty(
            (self.svr.ncell, self.svr.neq, self.svr.ndim),
            dtype=self.svr.fpdtype)
        asol.fill(0.0)
        self._calculate(asol)
        self.svr.soln[self.svr.ngstcell:,:] = asol
        self.svr.dsoln[self.svr.ngstcell:,:,:] = adsol
        # difference.
        diff = self.svr.der['difference'] = empty(
            (self.svr.ncell, self.svr.neq), dtype=self.svr.fpdtype)
        diff[:,:] = self.svr.soln[self.svr.ngstcell:,:] - asol
    def postfull(self):
        # plane wave solution.
        asol = self.svr.der['analytical']
        asol.fill(0.0)
        self._calculate(asol)
        # difference.
        diff = self.svr.der['difference']
        diff[:,:] = self.svr.soln[self.svr.ngstcell:,:] - asol
class PlaneWaveHook(BlockHook):
    def __init__(self, svr, **kw):
        self.planewaves = kw.pop('planewaves')
        self.norm = dict()
        super(PlaneWaveHook, self).__init__(svr, **kw)
    def drop_anchor(self, svr):
        svr.runanchors.append(
            PlaneWaveAnchor(svr, planewaves=self.planewaves)
        )
    def _calculate(self):
        from numpy import empty, sqrt, abs
        var = self.cse.execution.var
        asol = self._collect_interior(
            'analytical', inder=True, consider_ghost=False)
        diff = self._collect_interior(
            'difference', inder=True, consider_ghost=False)
        norm_Linf = empty(9, dtype='float64')
        norm_L2 = empty(9, dtype='float64')
        clvol = self.blk.clvol
        for it in range(9):
            norm_Linf[it] = abs(diff[:,it]).max()
            norm_L2[it] = sqrt((diff[:,it]**2*clvol).sum())
        self.norm['Linf'] = norm_Linf
        self.norm['L2'] = norm_L2
    def preloop(self):
        from numpy import pi
        self.postmarch()
        for ipw in range(len(self.planewaves)):
            pw = self.planewaves[ipw]
            self.info("planewave[%d]:\n" % ipw)
            self.info("  c = %g, omega = %g, T = %.15e\n" % (
                pw.wsp, pw.afreq, 2*pi/pw.afreq))
    def postmarch(self):
        psteps = self.psteps
        istep = self.cse.execution.step_current
        if istep%psteps == 0:
            self._calculate()
    def postloop(self):
        import os
        from cPickle import dump
        fname = '%s_norm.pickle' % self.cse.io.basefn
        fname = os.path.join(self.cse.io.basedir, fname)
        dump(self.norm, open(fname, 'wb'), -1)
        self.info('Linf norm in velocity:\n')
        self.info('  %e, %e, %e\n' % tuple(self.norm['Linf'][:3]))
        self.info('L2 norm in velocity:\n')
        self.info('  %e, %e, %e\n' % tuple(self.norm['L2'][:3]))

def mesher(cse):
    from solvcon.helper import Cubit

    itv = float(cse.io.basefn.split('_')[-1])/1000

    cmds = """
    # geometry.
    create vertex -1 -1 -1
    create vertex 1 -1 -1
    create vertex 1 1 -1
    create vertex -1 1 -1
    create curve 1 2
    create curve 2 3
    create curve 3 4
    create curve 4 1
    create surface 1 2 3 4
    sweep surface 1 direction z distance 1
    block 1 volume 1
    block 1 name "rear"
    volume 1 copy move z 1
    block 2 volume 2
    block 2 name "front"
    merge all surface
    sideset 1 surface 11
    sideset 2 surface 6
    sideset 3 surface 4 9
    sideset 4 surface 5 10
    sideset 5 surface 2 7
    sideset 6 surface 3 8
    sideset 1 name "front"
    sideset 2 name "rear"
    sideset 3 name "lower"
    sideset 4 name "left"
    sideset 5 name "upper"
    sideset 6 name "right"
    # mesh.
    volume 1 2 size %g
    surface 6 4 9 5 10 scheme trimesh
    mesh surface 6 4 9 5 10
    copy mesh surface 6 onto surface 11 source curve 3 target curve 13 \
        source vertex 4 target vertex 13 nosmoothing
    copy mesh surface 6 onto surface 1 source curve 3 target curve 5 \
        source vertex 4 target vertex 9 nosmoothing
    copy mesh surface 4 onto surface 2 source vertex 12 target vertex 9 \
        nosmoothing
    copy mesh surface 9 onto surface 7 source vertex 12 target vertex 9 \
        nosmoothing
    copy mesh surface 5 onto surface 3 source vertex 9 target vertex 10 \
        nosmoothing
    copy mesh surface 10 onto surface 8 source vertex 9 target vertex 10 \
        nosmoothing
    volume 1 2 scheme tetmesh
    mesh volume 1 2
    """ % itv

    cmds = [cmd.strip() for cmd in cmds.strip().split('\n')]
    gn = Cubit(cmds, 3)()
    return gn.toblock(bcname_mapper=cse.condition.bcmap)

def match_periodic(blk):
    from numpy import array
    from solvcon.boundcond import bctregy
    from solvcon.case import BlockCase
    bct = bctregy.CesePeriodic
    bcmap = {
        'left': (
            bct, {
                'link': 'right',
                'ref': array([0,-2,-2], dtype='float64'),
            }
        ),
        'lower': (
            bct, {
                'link': 'upper',
                'ref': array([-2,0,-2], dtype='float64'),
            }
        ),
        'rear': (
            bct, {
                'link': 'front',
                'ref': array([-2,-2,0], dtype='float64'),
            }
        ),
    }
    BlockCase.couple_periodic(blk, bcmap)

################################################################################
# Basic configuration.
################################################################################
def elas3d_base(casename=None, mtrlname='GaAs',
    al=20.0, be=40.0, ga=50.0, wtests=None, psteps=None, ssteps=None, **kw):
    """
    Fundamental configuration of the simulation and return the case object.

    @return: the created Case object.
    @rtype: solvcon.case.BlockCase
    """
    import os
    from numpy import pi, array, sin, cos, sqrt
    from solvcon.conf import env
    from solvcon.boundcond import bctregy
    from solvcon import hook, anchor
    from solvcon.solver import ALMOST_ZERO
    from solvcon.kerpak import cese
    #from solvcon.kerpak.elastic import mltregy
    from elastic import mltregy
    # set up BCs.
    bct = bctregy.BC
    bcmap = {
        'front': (bct, {}),
        'rear': (bct, {}),
        'left': (bct, {}),
        'right': (bct, {}),
        'upper': (bct, {}),
        'lower': (bct, {}),
    }
    # set up case.
    mtrl = mltregy[mtrlname](al=al*pi/180.0, be=be*pi/180.0, ga=ga*pi/180.0)
    basedir = os.path.join(os.path.abspath(os.getcwd()), 'result')
    cse = elastic.ElasticCase(basedir=basedir, rootdir=env.projdir,
        basefn=casename, mesher=mesher, bcmap=bcmap, bcmod=match_periodic,
        mtrldict={None: mtrl}, taylor=0.0, **kw)
    # statistical anchors for solvers.
    for name in 'Runtime', 'March', 'Tpool':
        cse.runhooks.append(getattr(anchor, name+'StatAnchor'))
    # informative hooks.
    cse.runhooks.append(hook.BlockInfoHook)
    cse.runhooks.append(hook.ProgressHook, psteps=psteps,
        linewidth=ssteps/psteps)
    cse.runhooks.append(cese.CflHook, fullstop=False, psteps=ssteps,
        cflmax=10.0, linewidth=ssteps/psteps)
    # initializer anchors..
    cse.runhooks.append(anchor.FillAnchor, keys=('soln',), value=ALMOST_ZERO)
    cse.runhooks.append(anchor.FillAnchor, keys=('dsoln',), value=0)
    ## plane wave solution.
    pws = list()
    for wvec, idx in wtests:
        pws.append(PlaneWaveSolution(mtrl=mtrl, amp=1.0, idx=idx,
            ctr=array([0,0,0], dtype='float64'), wvec=wvec))
    cse.runhooks.append(PlaneWaveHook, psteps=ssteps, planewaves=pws)
    # analyzing/output anchors and hooks.
    #cse.runhooks.append(euler.ElasticOAnchor)
    cse.runhooks.append(hook.PMarchSave, anames=[
            ('soln', False, -9),
        ], fpdtype='float64', psteps=ssteps, compressor='gz')
    return cse

def elas3d_skel(casename, div, std, **kw):
    from numpy import array, pi, sqrt
    period = 2.649983322636356e-04
    return elas3d_base(casename=casename,
        time_increment=period/div, steps_run=2*div, ssteps=div, psteps=std,
        wtests=(
            (array([1,1,0], dtype='float64')*pi, 8),
        ), **kw)

################################################################################
# The arrangement for demonstration.
################################################################################
@elastic.ElasticCase.register_arrangement
def elas3d(casename, **kw):
    return elas3d_skel(casename=casename, div=36, std=1)

################################################################################
# The arrangement for convergence test.
################################################################################
@elastic.ElasticCase.register_arrangement
def elas3d_200(casename, **kw):
    return elas3d_skel(casename=casename, div=34, std=1)
@elastic.ElasticCase.register_arrangement
def elas3d_150(casename, **kw):
    return elas3d_skel(casename=casename, div=44, std=1)
@elastic.ElasticCase.register_arrangement
def elas3d_100(casename, **kw):
    return elas3d_skel(casename=casename, div=72, std=2)

################################################################################
# Invoke SOLVCON workflow.
################################################################################
if __name__ == '__main__':
    import solvcon
    solvcon.go()
