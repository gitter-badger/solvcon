#!/usr/bin/env python2.6
# -*- coding: UTF-8 -*-
#
# Copyright (C) 2010-2011 Yung-Yu Chen <yyc@solvcon.net>.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

"""
Supersonic jet in cross flow.  Temporal parameters, e.g., time_increments,
steps_run, etc., are calculated based on the casename.  The casename should be
in the format of jcf_nnn, where nnn denotes the size of cells in the unit of
mm.  Large simulations can be created by adding arrangements with the naming
convetion.  By default, steps_run is set to have the free stream pass the
computing domain one and half time.

Run the simulations using: ./go run jcf_500
"""

from solvcon.kerpak import gasdyn
from solvcon.anchor import VtkAnchor

################################################################################
# In situ visualization.
################################################################################
class CutVtkAnchor(VtkAnchor):
    def process(self, istep):
        from solvcon.visual_vtk import Vop
        self._aggregate()
        self.svr.ust.GetCellData().SetActiveScalars('p')
        usp = Vop.c2p(self.svr.ust)
        usp.Update()
        fts = list()
        #cut = Vop.cut(usp, (0,0,1), (0,0,1))
        #cnr = Vop.contour_range(cut, 50, 30000, 300000)
        #cnr.Update()
        #fts.append(cnr)
        fts.append(Vop.cut(usp, (0,0.1,0), (0,1,0)))
        fts[-1].Update()
        fts.append(Vop.cut(usp, (0,4.5,0), (0,0,1)))
        fts[-1].Update()
        #fts.append(Vop.contour_value(usp, 0, 300000))
        #fts[-1].Update()
        lpd = Vop.lump_poly(*fts)
        Vop.write_poly(lpd, self.vtkfn)

################################################################################
# Mesh generation.
################################################################################
def mesher(cse):
    """
    Generate mesh according to the CUBIT journaling file jcf.tmpl.  It also
    determines time_increment.
    """
    from solvcon.helper import Cubit
    itv = float(cse.io.basefn.split('_')[-1])/1000
    cmds = open('jcf.tmpl').read() % itv
    cmds = [cmd.strip() for cmd in cmds.strip().split('\n')]
    gn = Cubit(cmds, 3, large=False)()
    return gn.toblock(bcname_mapper=cse.condition.bcmap)

################################################################################
# Basic configuration.
################################################################################
def jcf_base(casename=None,
    gamma=None, rhoi=None, prei=None, Mi=None, rhoj=None, prej=None, Mj=None,
    nonslip=False, **kw):
    """
    Fundamental configuration of the simulation and return the case object.

    @return: the created Case object.
    @rtype: solvcon.case.BlockCase
    """
    import os
    from math import log10, floor, ceil
    from numpy import sqrt
    from solvcon.helper import search_in_parents
    from solvcon.conf import env
    from solvcon.boundcond import bctregy
    from solvcon.solver import ALMOST_ZERO
    from solvcon import hook, anchor
    from solvcon.kerpak import cuse
    # set flow properties (fp).
    fpi = {'gamma': gamma, 'rho': rhoi, 'p': prei, 'v2': 0.0, 'v3': 0.0}
    fpi['v1'] = Mi*sqrt(gamma*fpi['p']/fpi['rho'])
    fpj = {'gamma': gamma, 'rho': rhoj, 'p': prej, 'v1': 0.0, 'v3': 0.0}
    fpj['v2'] = Mj*sqrt(gamma*fpj['p']/fpj['rho'])
    # determine temporal parameters.
    itv = float(casename.split('_')[-1])/1000
    time_increment = itv/0.5*2.2e-4
    time_stop = 18./fpi['v1']*1.5
    steps_run = int(time_stop/time_increment)
    ssteps = int(10**(floor(log10(steps_run))-1))*2
    psteps = int(ceil(float(ssteps)/50))
    # set up BCs.
    wallbct = bctregy.GasdynNswall if nonslip else bctregy.GasdynWall
    bcmap = {
        'jet': (bctregy.GasdynInlet, fpj,),
        'upstream': (bctregy.GasdynInlet, fpi,),
        'downstream': (bctregy.CuseNonrefl, {},),
        'side': (bctregy.CuseNonrefl, {},),
        'top': (bctregy.CuseNonrefl, {},),
        'wall': (wallbct, {},),
    }
    # set up case.
    basedir = os.path.join(os.path.abspath(os.getcwd()), 'result')
    cse = gasdyn.GasdynCase(basedir=basedir, rootdir=env.projdir,
        time_increment=time_increment, steps_run=steps_run,
        basefn=casename, mesher=mesher, bcmap=bcmap, **kw)
    # statistical anchors for solvers.
    for name in 'Runtime', 'March':
        cse.runhooks.append(getattr(anchor, name+'StatAnchor'))
    # informative hooks.
    cse.runhooks.append(hook.BlockInfoHook)
    cse.runhooks.append(hook.ProgressHook, psteps=psteps,
        linewidth=ssteps/psteps)
    cse.runhooks.append(cuse.CflHook, fullstop=False, psteps=ssteps,
        cflmax=10.0, linewidth=ssteps/psteps)
    cse.runhooks.append(cuse.ConvergeHook, psteps=ssteps)
    # initializer anchors..
    cse.runhooks.append(anchor.FillAnchor, keys=('soln',), value=ALMOST_ZERO)
    cse.runhooks.append(anchor.FillAnchor, keys=('dsoln',), value=0)
    cse.runhooks.append(gasdyn.UniformIAnchor, **fpi)
    # analyzing/output anchors and hooks.
    cse.runhooks.append(gasdyn.GasdynOAnchor)
    cse.runhooks.append(hook.PMarchSave, anames=[
        #('soln', False, -5),
        ('rho', True, 0),
        ('p', True, 0),
        #('T', True, 0),
        #('ke', True, 0),
        ('M', True, 0),
        ('sch', True, 0),
        ('v', True, 0.5),
    ], psteps=ssteps, fpdtype='float32', compressor='gz')
    cse.runhooks.append(hook.PVtkHook, anames=[
        #('soln', False, -5),
        ('rho', True, 0),
        ('p', True, 0),
        #('T', True, 0),
        #('ke', True, 0),
        ('M', True, 0),
        ('sch', True, 0),
        ('v', True, 0.5),
    ], ankcls=CutVtkAnchor, psteps=ssteps)
    return cse

def jcf_skel(casename, **kw):
    """
    Default values for simulation parameters.
    """
    return jcf_base(casename=casename,
        gamma=1.4, Mi=1.98, rhoi=0.86, prei=41.8e3, Mj=1.02, rhoj=6.64,
        prej=476.e3, diffname='tau', tauname='scale', taumin=0.1, tauscale=0.9,
        nonslip=True, **kw)

################################################################################
# Example arrangements.
################################################################################
@gasdyn.GasdynCase.register_arrangement
def jcf_500(casename, **kw):
    return jcf_skel(casename=casename, **kw)

if __name__ == '__main__':
    import solvcon
    solvcon.go()
