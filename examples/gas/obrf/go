#!/usr/bin/env python2.7
# -*- coding: UTF-8 -*-
#
# Copyright (c) 2014, Yung-Yu Chen <yyc@solvcon.net>
#
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# - Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
# - Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
# - Neither the name of the SOLVCON nor the names of its contributors may be
#   used to endorse or promote products derived from this software without
#   specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.


"""
This is a two-dimensional example of the reflection of oblique shock wave.
"""


import os

import numpy as np

import solvcon as sc

from solvcon import helper
from solvcon.parcel import gas


class ObliqueShockReflection(gas.ObliqueShockRelation):
    def __init__(self, gamma, theta, mach1, rho1, p1, T1):
        super(ObliqueShockReflection, self).__init__(gamma=gamma)

        # Angles and Mach numbers.
        self.theta = theta
        self.mach1 = mach1
        self.beta1 = beta1 = self.calc_shock_angle(mach1, theta)
        self.mach2 = mach2 = self.calc_dmach(mach1, beta1)
        self.beta2 = beta2 = self.calc_shock_angle(mach2, theta)
        self.mach3 = mach3 = self.calc_dmach(mach2, beta2)

        # Flow properties in the first zone.
        self.rho1 = rho1
        self.p1 = p1
        self.T1 = T1
        self.a1 = np.sqrt(gamma*p1/rho1)

        # Flow properties in the second zone.
        self.rho2 = rho2 = rho1 * self.calc_density_ratio(mach1, beta1)
        self.p2 = p2 = p1 * self.calc_pressure_ratio(mach1, beta1)
        self.T2 = T2 = T1 * self.calc_temperature_ratio(mach1, beta1)
        self.a2 = np.sqrt(gamma*p2/rho2)

        # Flow properties in the third zone.
        self.rho3 = rho3 = rho2 * self.calc_density_ratio(mach2, beta2)
        self.p3 = p3 = p2 * self.calc_pressure_ratio(mach2, beta2)
        self.T3 = T3 = T2 * self.calc_temperature_ratio(mach2, beta2)
        self.a3 = np.sqrt(gamma*p3/rho3)

class ExactObshockHook(sc.MeshHook):
    """
    Show the exact solution for the reflection of oblique shock wave.
    """

    def __init__(self, cse, **kw):
        self.theta = kw.pop('theta')
        self.mach1 = kw.pop('mach1')
        self.gamma = kw.pop('gamma')
        self.p1 = kw.pop('p')
        self.rho1 = kw.pop('rho')
        self.region = kw.pop('region', 2)
        super(ExactObshockHook, self).__init__(cse, **kw)

    def _calculate(self):
        obs = ObliqueShockReflection(
            gamma=self.gamma, theta=self.theta, mach1=self.mach1,
            rho1=self.rho1, p1=self.p1, T1=1)
        self.info('Oblique shock relation (exact):\n')
        self.info('  theta = %.3f deg (flow angle)\n' % (obs.theta/np.pi*180))
        self.info('  beta  = %.3f deg (shock angle)\n' % (obs.beta1/np.pi*180))
        self.info('  mach2 = %.10f\n' % obs.mach2)
        self.info('  rho2  = %.10f\n' % obs.rho2)
        self.info('  p2    = %.10f\n' % obs.p2)
        if self.region >= 3:
            self.info('  beta2   = %.3f deg (shock angle)\n' % (obs.beta2/np.pi*180))
            self.info('  - theta = %.3f deg (shock - flow angle)\n' % (
                (obs.beta2-obs.theta)/np.pi*180))
            self.info('  mach3   = %.10f\n' % obs.mach3)
            self.info('  rho3    = %.10f\n' % obs.rho3)
            self.info('  p3      = %.10f\n' % obs.p3)

    def preloop(self):
        self._calculate()

    postloop = preloop


class ReflProbe(gas.ProbeHook):
    """
    Place a probe for the flow properties in the reflected region.
    """
    def __init__(self, cse, **kw):
        kw['speclst'] = ['M', 'rho', 'p']
        # calculate exact solution.
        theta = kw.pop('theta')
        mach1 = kw.pop('mach1')
        gamma = kw.pop('gamma')
        p1 = kw.pop('p')
        rho1 = kw.pop('rho')
        obs = ObliqueShockReflection(gamma=gamma, theta=theta, mach1=mach1,
                                     rho1=rho1, p1=p1, T1=1)
        self.mach3 = obs.mach3
        self.rho3 = obs.rho3
        self.p3 = obs.p3
        beta1 = obs.beta1
        beta2 = obs.beta2
        # detemine location.
        x0 = kw.pop('x0')
        y0 = kw.pop('y0')
        z0 = kw.pop('z0', None)
        x1 = kw.pop('x1')
        y1 = kw.pop('y1')
        z1 = kw.pop('z1', None)
        factor = kw.pop('factor', 0.9)
        lgh = (y1-y0) / np.tan(beta1)
        hgt = factor * (x1-x0-lgh) * np.tan((beta2-theta)/2)
        lgh = factor * (x1-x0-lgh) + lgh
        if None is not z0:
            poi = ('poi', lgh, hgt, (z1+z0)/2)
        else:
            poi = ('poi', lgh, hgt)
        kw['coords'] = (poi,)
        # ancestor.
        super(ReflProbe, self).__init__(cse, **kw)

    def postloop(self):
        super(ReflProbe, self).postloop()
        self.info('Probe result at %s:\n' % self.points[0])
        M, rho, p = self.points[0].vals[-1][1:]
        self.info('  mach3   = %.3f/%.3f (error=%%%.2f)\n' % (M, self.mach3,
            abs((M-self.mach3)/self.mach3)*100))
        self.info('  rho3 = %.3f/%.3f (error=%%%.2f)\n' % (rho, self.rho3,
            abs((rho-self.rho3)/self.rho3)*100))
        self.info('  p3   = %.3f/%.3f (error=%%%.2f)\n' % (p, self.p3,
            abs((p-self.p3)/self.p3)*100))


################################################################################
# Mesh generation.
################################################################################
def mesher(cse):
    """
    Generate mesh according to the Gmsh command template file obrf.tmpl.
    """
    itv = float(cse.io.meshfn)/1000
    cmds = open('obrf.tmpl').read() % itv
    cmds = [cmd.strip() for cmd in cmds.strip().split('\n')]
    gmh = helper.Gmsh(cmds)()
    return gmh.toblock(bcname_mapper=cse.condition.bcmap)

def obrf_base(casename=None, meshname=None,
    gamma=None, density=None, pressure=None, mach=None, theta=None,
    psteps=None, ssteps=None, **kw
):
    """
    Fundamental configuration of the simulation and return the case object.

    @return: the created Case object.
    @rtype: solvcon.parcel.gas.GasCase
    """
    # set flow properties (fp).
    fpb = {
        'gamma': gamma, 'rho': density, 'v2': 0.0, 'v3': 0.0, 'p': pressure,
    }
    fpb['v1'] = mach*np.sqrt(gamma*fpb['p']/fpb['rho'])
    fpt = fpb.copy()
    ob = ObliqueShockReflection(gamma=gamma, theta=theta, mach1=mach,
                                rho1=density, p1=pressure, T1=1)
    fpt['rho'] = ob.rho2
    fpt['p'] = ob.p2
    V2 = ob.mach2 * ob.a2
    fpt['v1'] = V2 * np.cos(theta)
    fpt['v2'] = -V2 * np.sin(theta)
    fpi = fpb.copy()
    # set up BCs.
    bcmap = {
        'upper': (sc.bctregy.GasInlet, fpt,),
        'left': (sc.bctregy.GasInlet, fpb,),
        'right': (sc.bctregy.GasNonrefl, {},),
        'lower': (sc.bctregy.GasWall, {},),
    }
    # set up case.
    basedir = os.path.abspath(os.path.join(os.getcwd(), 'result'))
    cse = gas.GasCase(basedir=basedir, rootdir=sc.env.projdir,
        basefn=casename, mesher=mesher, bcmap=bcmap, debug=False, **kw)
    # informative.
    cse.runhooks.append(gas.ProgressHook,
        psteps=psteps, linewidth=ssteps/psteps,
    )
    cse.runhooks.append(gas.CflHook, fullstop=False, psteps=ssteps,
        cflmax=10.0, linewidth=ssteps/psteps,
    )
    cse.runhooks.append(gas.MeshInfoHook, psteps=ssteps)
    # initializer.
    cse.runhooks.append(gas.FillAnchor,
                        mappers={'soln': gas.GasSolver.ALMOST_ZERO,
                                 'dsoln': 0.0,
                                 'amsca': gamma})
    cse.runhooks.append(gas.DensityInitAnchor, rho=1.0)
    # post processing.
    cse.runhooks.append(gas.PhysicsAnchor, rsteps=ssteps)
    ## execution order is reversed for postloop.
    cse.runhooks.append(ReflProbe, psteps=ssteps,
        x0=0, x1=4, y0=0, y1=1, z0=0, z1=0, theta=theta, mach1=mach, **fpb)
    cse.runhooks.append(ExactObshockHook, region=3, theta=theta, mach1=mach,
                        **fpb)
    ## output.
    cse.runhooks.append(gas.PMarchSave, anames=[
            ('soln', False, -4),
        ], fpdtype='float64', psteps=ssteps, compressor='gz')
    return cse


@gas.GasCase.register_arrangement
def obrf(casename, **kw):
    """
    The true arrangement which specifies necessary parameters for execution.
    """
    return obrf_base(casename, meshfn='100',
        gamma=1.4, density=1.0, pressure=1.0, mach=3.0, theta=10.0/180*np.pi,
        time_increment=7.e-3, steps_run=600, ssteps=100, psteps=2, **kw)


if __name__ == '__main__':
    sc.go()

# vim: set ff=unix fenc=utf8 ft=python ai et sw=4 ts=4 tw=79:
